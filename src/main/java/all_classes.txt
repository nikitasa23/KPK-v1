===== com/example/examplemod/chat/ChatChannel.java =====
package com.example.examplemod.chat;

import io.netty.buffer.ByteBuf;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.nbt.NBTTagString;
import net.minecraftforge.common.util.Constants;
import net.minecraftforge.fml.common.network.ByteBufUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

public class ChatChannel {
    private String channelId;
    private String displayName;
    private ChatChannelType type;
    private List<UUID> members;
    private UUID creatorUuid;
    private int maxMembers;

    public static final String COMMON_CHANNEL_ID_PREFIX = "common_server_global";

    public ChatChannel() {
        this.members = new ArrayList<>();
    }

    public ChatChannel(String channelId, String displayName, ChatChannelType type) {
        this.channelId = channelId;
        this.displayName = displayName;
        this.type = type;
        this.members = new ArrayList<>();
        this.creatorUuid = null;
        this.maxMembers = Integer.MAX_VALUE;
    }

    public ChatChannel(String channelId, String displayName, ChatChannelType type, UUID creatorUuid, List<UUID> initialMembers, int maxMembers) {
        this.channelId = channelId;
        this.displayName = displayName;
        this.type = type;
        this.creatorUuid = creatorUuid;
        this.members = new ArrayList<>(initialMembers);
        if (!this.members.contains(creatorUuid) && type != ChatChannelType.COMMON_SERVER_WIDE) {
            this.members.add(creatorUuid);
        }
        this.maxMembers = maxMembers;
    }

    public String getChannelId() {
        return channelId;
    }

    public String getDisplayName() {
        return displayName;
    }

    public ChatChannelType getType() {
        return type;
    }

    public List<UUID> getMembers() {
        return new ArrayList<>(members);
    }

    public UUID getCreatorUuid() {
        return creatorUuid;
    }

    public int getMaxMembers() {
        return maxMembers;
    }

    public void setDisplayName(String displayName) {
        this.displayName = displayName;
    }

    public boolean addMember(UUID memberUuid) {
        if (members.size() < maxMembers && !members.contains(memberUuid)) {
            members.add(memberUuid);
            return true;
        }
        return false;
    }

    public boolean removeMember(UUID memberUuid) {
        return members.remove(memberUuid);
    }

    public boolean isMember(UUID memberUuid) {
        if (type == ChatChannelType.COMMON_SERVER_WIDE) return true;
        return members.contains(memberUuid);
    }

    public NBTTagCompound toNBT() {
        NBTTagCompound nbt = new NBTTagCompound();
        nbt.setString("channelId", channelId);
        nbt.setString("displayName", displayName);
        nbt.setString("type", type.name());
        if (creatorUuid != null) {
            nbt.setString("creatorUuid", creatorUuid.toString());
        }
        nbt.setInteger("maxMembers", maxMembers);

        NBTTagList memberListNBT = new NBTTagList();
        for (UUID member : members) {
            memberListNBT.appendTag(new NBTTagString(member.toString()));
        }
        nbt.setTag("members", memberListNBT);
        return nbt;
    }

    public static ChatChannel fromNBT(NBTTagCompound nbt) {
        ChatChannel channel = new ChatChannel();
        channel.channelId = nbt.getString("channelId");
        channel.displayName = nbt.getString("displayName");
        channel.type = ChatChannelType.valueOf(nbt.getString("type"));
        if (nbt.hasKey("creatorUuid")) {
            try {
                channel.creatorUuid = UUID.fromString(nbt.getString("creatorUuid"));
            } catch (IllegalArgumentException e) {
                channel.creatorUuid = null;
            }
        }
        channel.maxMembers = nbt.getInteger("maxMembers");

        NBTTagList memberListNBT = nbt.getTagList("members", Constants.NBT.TAG_STRING);
        for (int i = 0; i < memberListNBT.tagCount(); i++) {
            try {
                channel.members.add(UUID.fromString(memberListNBT.getStringTagAt(i)));
            } catch (IllegalArgumentException e) {
            }
        }
        return channel;
    }

    public void toBytes(ByteBuf buf) {
        ByteBufUtils.writeUTF8String(buf, channelId);
        ByteBufUtils.writeUTF8String(buf, displayName);
        ByteBufUtils.writeUTF8String(buf, type.name());
        buf.writeBoolean(creatorUuid != null);
        if (creatorUuid != null) {
            ByteBufUtils.writeUTF8String(buf, creatorUuid.toString());
        }
        buf.writeInt(maxMembers);
        buf.writeInt(members.size());
        for (UUID member : members) {
            ByteBufUtils.writeUTF8String(buf, member.toString());
        }
    }

    public static ChatChannel fromBytes(ByteBuf buf) {
        ChatChannel channel = new ChatChannel();
        channel.channelId = ByteBufUtils.readUTF8String(buf);
        channel.displayName = ByteBufUtils.readUTF8String(buf);
        channel.type = ChatChannelType.valueOf(ByteBufUtils.readUTF8String(buf));
        if (buf.readBoolean()) {
            channel.creatorUuid = UUID.fromString(ByteBufUtils.readUTF8String(buf));
        }
        channel.maxMembers = buf.readInt();
        int memberCount = buf.readInt();
        for (int i = 0; i < memberCount; i++) {
            channel.members.add(UUID.fromString(ByteBufUtils.readUTF8String(buf)));
        }
        return channel;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ChatChannel that = (ChatChannel) o;
        return Objects.equals(channelId, that.channelId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(channelId);
    }

    public static String generatePMChannelId(UUID user1, UUID user2) {
        String id1 = user1.toString();
        String id2 = user2.toString();
        if (id1.compareTo(id2) > 0) {
            return "pm_" + id2 + "_" + id1;
        } else {
            return "pm_" + id1 + "_" + id2;
        }
    }

    public static String generateGroupChannelId(UUID creatorUuid, String channelName) {
        String safeName = channelName.replaceAll("[^a-zA-Z0-9А-Яа-яЁё]", "").toLowerCase();
        if(safeName.length() > 10) safeName = safeName.substring(0, 10);
        return "grp_" + creatorUuid.toString().substring(0, 4) + "_" + safeName + "_" + (System.currentTimeMillis() % 10000);
    }
}===== com/example/examplemod/chat/ChatChannelType.java =====
package com.example.examplemod.chat;

public enum ChatChannelType {
    COMMON_SERVER_WIDE,
    PRIVATE_MESSAGE,
    PRIVATE_GROUP
}===== com/example/examplemod/chat/ChatManager.java =====
package com.example.examplemod.chat;

import com.example.examplemod.User;
import com.example.examplemod.item.ItemKPK;
import com.example.examplemod.kpk.KPKServerManager;
import com.example.examplemod.network.PacketBroadcastChatMessageToClient;
import com.example.examplemod.network.PacketHandler;
import com.example.examplemod.network.PacketNotifyChannelCreatedOrUpdated;
import com.example.examplemod.network.PacketNotifyChannelDeleted;
import com.example.examplemod.network.PacketSyncChatHistoryToClient;
import com.example.examplemod.network.PacketSyncSubscribedChannels;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextFormatting;
import net.minecraft.world.storage.MapStorage;
import net.minecraft.world.storage.WorldSavedData;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraftforge.common.util.Constants;
import net.minecraftforge.fml.common.FMLCommonHandler;
import org.apache.commons.lang3.tuple.Pair;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

public class ChatManager {
    private static final String CHAT_DATA_ID = "examplemod_chatdata_v2";
    private static ChatWorldData chatData;

    private static final Map<String, LinkedList<ChatMessage>> chatHistories = new ConcurrentHashMap<>();
    private static final int MAX_HISTORY_PER_CHANNEL = 50;

    public static void load(MinecraftServer server) {
        if (server == null || server.getWorld(0) == null) {
            System.err.println("ChatManager: Cannot load, server or overworld is null!");
            return;
        }
        MapStorage storage = server.getWorld(0).getMapStorage();
        chatData = (ChatWorldData) storage.getOrLoadData(ChatWorldData.class, CHAT_DATA_ID);
        if (chatData == null) {
            chatData = new ChatWorldData(CHAT_DATA_ID);
            storage.setData(CHAT_DATA_ID, chatData);
        }

        if (chatData.getChannel(ChatChannel.COMMON_CHANNEL_ID_PREFIX) == null) {
            ChatChannel commonChannel = new ChatChannel(ChatChannel.COMMON_CHANNEL_ID_PREFIX, "Общий", ChatChannelType.COMMON_SERVER_WIDE);
            chatData.addOrUpdateChannel(commonChannel);
        }

        chatHistories.clear();
        chatData.loadHistories(chatHistories, MAX_HISTORY_PER_CHANNEL);

        System.out.println("[ExampleMod] ChatManager loaded. Channels: " + chatData.getAllChannels().size());
    }

    public static void save(MinecraftServer server) {
        if (chatData != null && server != null && server.getWorld(0) != null) {
            chatData.saveHistories(chatHistories);
            MapStorage storage = server.getWorld(0).getMapStorage();
            storage.setData(CHAT_DATA_ID, chatData);
            System.out.println("[ExampleMod] ChatManager data saved.");
        } else {
            System.err.println("[ExampleMod] ChatManager could not save data (chatData or server is null).");
        }
    }

    @Nullable
    private static Pair<UUID, User> getKPKUserAndOwner(EntityPlayerMP player) {
        ItemStack mainHand = player.getHeldItemMainhand();
        if (!(mainHand.getItem() instanceof ItemKPK) || !ItemKPK.isEnabled(mainHand)) {
            mainHand = player.getHeldItemOffhand();
        }

        if (mainHand.getItem() instanceof ItemKPK && ItemKPK.isEnabled(mainHand)) {
            User kpkUser = ItemKPK.getUserData(mainHand);
            if (kpkUser != null && kpkUser.pozivnoy != null && !kpkUser.pozivnoy.isEmpty()) {
                Pair<UUID, User> serverData = KPKServerManager.findUserByCallsign(kpkUser.pozivnoy);
                if (serverData != null) {
                    return serverData;
                }
            }
        }

        User ownUser = KPKServerManager.getUser(player.getUniqueID());
        if (ownUser != null) {
            return Pair.of(player.getUniqueID(), ownUser);
        }

        return null;
    }

    public static List<ChatChannel> getSubscribedChannels(EntityPlayerMP player) {
        if (chatData == null) return Collections.emptyList();

        Pair<UUID, User> actingUser = getKPKUserAndOwner(player);
        if (actingUser == null) return Collections.emptyList();
        UUID actingUuid = actingUser.getLeft();

        return chatData.getAllChannels().stream()
                .filter(channel -> channel.isMember(actingUuid))
                .collect(Collectors.toList());
    }

    @Nullable
    public static ChatChannel getChannel(String channelId) {
        if (chatData == null) return null;
        return chatData.getChannel(channelId);
    }

    public static boolean createPrivateMessageChannel(EntityPlayerMP creatorPlayer, UUID targetPlayerUuid) {
        if (chatData == null) return false;

        Pair<UUID, User> creatorIdentity = getKPKUserAndOwner(creatorPlayer);
        if (creatorIdentity == null) {
            creatorPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Ваш КПК не инициализирован или вы не держите его в руке."));
            return false;
        }
        UUID creatorUuid = creatorIdentity.getLeft();
        User creatorUser = creatorIdentity.getRight();

        MinecraftServer server = FMLCommonHandler.instance().getMinecraftServerInstance();
        EntityPlayerMP targetPlayer = server.getPlayerList().getPlayerByUUID(targetPlayerUuid);

        if (targetPlayer == null) {
            creatorPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Целевой игрок не найден (оффлайн?)."));
            return false;
        }

        Pair<UUID, User> targetIdentity = getKPKUserAndOwner(targetPlayer);
        if (targetIdentity == null) {
            creatorPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "КПК целевого игрока не инициализирован или не находится в руке."));
            return false;
        }
        UUID targetUuid = targetIdentity.getLeft();
        User targetUser = targetIdentity.getRight();

        boolean isSelfChat = creatorUuid.equals(targetUuid);

        String channelId = ChatChannel.generatePMChannelId(creatorUuid, targetUuid);
        if (chatData.getChannel(channelId) != null) {
            creatorPlayer.sendMessage(new TextComponentString(TextFormatting.YELLOW + "ЛС с " + targetPlayer.getName() + " уже существует."));
            return true;
        }

        List<UUID> members = new ArrayList<>();
        members.add(creatorUuid);
        if (!isSelfChat) {
            members.add(targetUuid);
        }

        String displayName = "ЛС: " + creatorUser.pozivnoy + " / " + targetUser.pozivnoy;
        ChatChannel pmChannel = new ChatChannel(channelId, displayName, ChatChannelType.PRIVATE_MESSAGE, creatorUuid, members, 2);

        chatData.addOrUpdateChannel(pmChannel);
        chatHistories.putIfAbsent(channelId, new LinkedList<>());
        chatData.markDirty();

        PacketNotifyChannelCreatedOrUpdated packet = new PacketNotifyChannelCreatedOrUpdated(pmChannel);

        EntityPlayerMP creatorOnline = server.getPlayerList().getPlayerByUUID(creatorUuid);
        if(creatorOnline != null) PacketHandler.INSTANCE.sendTo(packet, creatorOnline);

        if (!isSelfChat) {
            EntityPlayerMP targetOnline = server.getPlayerList().getPlayerByUUID(targetUuid);
            if(targetOnline != null) PacketHandler.INSTANCE.sendTo(packet, targetOnline);
        }

        creatorPlayer.sendMessage(new TextComponentString(TextFormatting.GREEN + "ЛС с " + targetPlayer.getName() + " создано."));
        if (!isSelfChat) {
            targetPlayer.sendMessage(new TextComponentString(TextFormatting.GREEN + creatorPlayer.getName() + " создал(а) ЛС с вами."));
        }
        return true;
    }

    public static boolean createPrivateGroupChannel(EntityPlayerMP creatorPlayer, String channelName, List<UUID> targetMemberUuidsFromContacts) {
        if (chatData == null) return false;

        Pair<UUID, User> creatorIdentity = getKPKUserAndOwner(creatorPlayer);
        if (creatorIdentity == null) {
            creatorPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Ваш КПК не инициализирован или вы не держите его в руке."));
            return false;
        }
        UUID creatorUuid = creatorIdentity.getLeft();

        if (channelName == null || channelName.trim().isEmpty() || channelName.length() > 20 || channelName.length() < 2) {
            creatorPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Неверное имя канала (2-20 симв)."));
            return false;
        }
        if (targetMemberUuidsFromContacts.size() > 2) {
            creatorPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Слишком много участников для ЗК (макс 2 выбранных + вы)."));
            return false;
        }

        String displayName = "ЗК: " + channelName.trim();
        for (ChatChannel existingChannel : chatData.getAllChannels()) {
            if (existingChannel.getType() == ChatChannelType.PRIVATE_GROUP && existingChannel.getDisplayName().equalsIgnoreCase(displayName)) {
                creatorPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Канал с названием '" + channelName.trim() + "' уже существует."));
                return false;
            }
        }

        List<UUID> allMemberUuids = new ArrayList<>(targetMemberUuidsFromContacts);
        if (!allMemberUuids.contains(creatorUuid)) {
            allMemberUuids.add(creatorUuid);
        }
        if (allMemberUuids.size() > 3) {
            creatorPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Общее число участников превышает 3."));
            return false;
        }

        MinecraftServer server = FMLCommonHandler.instance().getMinecraftServerInstance();
        for(UUID memberId : targetMemberUuidsFromContacts) {
            EntityPlayerMP memberPlayer = server.getPlayerList().getPlayerByUUID(memberId);
            if(memberPlayer == null) {
                creatorPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Один из выбранных участников не найден (оффлайн?)."));
                return false;
            }
            if (getKPKUserAndOwner(memberPlayer) == null){
                creatorPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "У участника " + memberPlayer.getName() + " не настроен КПК или он не в руке."));
                return false;
            }
        }

        String channelId = ChatChannel.generateGroupChannelId(creatorUuid, channelName);
        ChatChannel groupChannel = new ChatChannel(channelId, displayName, ChatChannelType.PRIVATE_GROUP, creatorUuid, allMemberUuids, 3);
        chatData.addOrUpdateChannel(groupChannel);
        chatHistories.putIfAbsent(channelId, new LinkedList<>());
        chatData.markDirty();

        creatorPlayer.sendMessage(new TextComponentString(TextFormatting.GREEN + "Закрытый канал '" + displayName + "' создан."));
        PacketNotifyChannelCreatedOrUpdated packet = new PacketNotifyChannelCreatedOrUpdated(groupChannel);
        for (UUID memberUuid : allMemberUuids) {
            EntityPlayerMP memberPlayer = server.getPlayerList().getPlayerByUUID(memberUuid);
            if (memberPlayer != null) {
                PacketHandler.INSTANCE.sendTo(packet, memberPlayer);
                if (!memberUuid.equals(creatorUuid)) {
                    memberPlayer.sendMessage(new TextComponentString(TextFormatting.GREEN + creatorPlayer.getName() + " добавил(а) вас в ЗК '" + displayName + "'."));
                }
            }
        }
        return true;
    }

    public static boolean deleteChannel(String channelId, EntityPlayerMP requesterPlayer) {
        if (chatData == null || channelId == null || requesterPlayer == null) return false;

        if (channelId.startsWith(ChatChannel.COMMON_CHANNEL_ID_PREFIX)) {
            requesterPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Нельзя покинуть общий канал."));
            return false;
        }

        ChatChannel channel = chatData.getChannel(channelId);
        if (channel == null) {
            requesterPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Канал не найден."));
            return false;
        }

        Pair<UUID, User> requesterIdentity = getKPKUserAndOwner(requesterPlayer);
        if (requesterIdentity == null) {
            requesterPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Ваш КПК не инициализирован."));
            return false;
        }
        UUID requesterUuid = requesterIdentity.getLeft();
        String requesterName = requesterIdentity.getRight().pozivnoy;

        if (!channel.isMember(requesterUuid)) {
            requesterPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Вы не являетесь участником этого канала."));
            return false;
        }

        MinecraftServer server = requesterPlayer.getServer();
        List<UUID> originalMembers = new ArrayList<>(channel.getMembers());

        switch (channel.getType()) {
            case PRIVATE_MESSAGE: {
                channel.removeMember(requesterUuid);
                chatData.addOrUpdateChannel(channel);
                requesterPlayer.sendMessage(new TextComponentString(TextFormatting.YELLOW + "Вы покинули чат '" + channel.getDisplayName() + "'."));

                PacketHandler.INSTANCE.sendTo(new PacketNotifyChannelDeleted(channelId), requesterPlayer);

                for (UUID otherMemberUuid : originalMembers) {
                    if (!otherMemberUuid.equals(requesterUuid)) {
                        EntityPlayerMP otherPlayer = server.getPlayerList().getPlayerByUUID(otherMemberUuid);
                        if (otherPlayer != null) {
                            otherPlayer.sendMessage(new TextComponentString(TextFormatting.YELLOW + "Пользователь " + requesterName + " покинул(а) чат с вами."));
                            PacketHandler.INSTANCE.sendTo(new PacketNotifyChannelCreatedOrUpdated(channel), otherPlayer);
                        }
                    }
                }

                if (channel.getMembers().isEmpty()) {
                    chatData.removeChannel(channelId);
                    chatHistories.remove(channelId);
                }
                break;
            }
            case PRIVATE_GROUP: {
                if (channel.getCreatorUuid().equals(requesterUuid)) {
                    // Creator disbands the channel
                    String messageToMembers = TextFormatting.YELLOW + "Канал '" + channel.getDisplayName() + "' был расформирован создателем.";
                    PacketNotifyChannelDeleted packet = new PacketNotifyChannelDeleted(channelId);

                    for (UUID memberUuid : originalMembers) {
                        EntityPlayerMP memberPlayer = server.getPlayerList().getPlayerByUUID(memberUuid);
                        if (memberPlayer != null) {
                            if (!memberUuid.equals(requesterUuid)) {
                                memberPlayer.sendMessage(new TextComponentString(messageToMembers));
                            }
                            PacketHandler.INSTANCE.sendTo(packet, memberPlayer);
                        }
                    }
                    requesterPlayer.sendMessage(new TextComponentString(TextFormatting.YELLOW + "Канал '" + channel.getDisplayName() + "' расформирован."));
                    chatData.removeChannel(channelId);
                    chatHistories.remove(channelId);
                } else {
                    // A member leaves the channel
                    channel.removeMember(requesterUuid);
                    chatData.addOrUpdateChannel(channel);
                    requesterPlayer.sendMessage(new TextComponentString(TextFormatting.YELLOW + "Вы покинули канал '" + channel.getDisplayName() + "'."));

                    PacketHandler.INSTANCE.sendTo(new PacketNotifyChannelDeleted(channelId), requesterPlayer);

                    String messageToMembers = TextFormatting.YELLOW + "Участник " + requesterName + " покинул(а) канал '" + channel.getDisplayName() + "'.";
                    PacketNotifyChannelCreatedOrUpdated updatePacket = new PacketNotifyChannelCreatedOrUpdated(channel);

                    for (UUID memberUuid : channel.getMembers()) {
                        EntityPlayerMP memberPlayer = server.getPlayerList().getPlayerByUUID(memberUuid);
                        if (memberPlayer != null) {
                            memberPlayer.sendMessage(new TextComponentString(messageToMembers));
                            PacketHandler.INSTANCE.sendTo(updatePacket, memberPlayer);
                        }
                    }
                }
                break;
            }
        }
        chatData.markDirty();
        return true;
    }

    public static void addMessageToChannel(EntityPlayerMP senderPlayer, ChatMessage chatMessage) {
        if (chatData == null || chatMessage == null || chatMessage.channelId == null || senderPlayer == null) return;

        ChatChannel channel = chatData.getChannel(chatMessage.channelId);
        if (channel == null) {
            System.err.println("[ExampleMod] Attempted to add message to non-existent channel: " + chatMessage.channelId);
            return;
        }

        Pair<UUID, User> senderIdentity = getKPKUserAndOwner(senderPlayer);
        if (senderIdentity == null) {
            senderPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Не удалось отправить сообщение: КПК не инициализирован."));
            return;
        }

        if (!channel.isMember(senderIdentity.getLeft())) {
            System.err.println("[ExampleMod] Player " + chatMessage.senderPlayerName + " tried to send message to channel " + channel.getChannelId() + " they are not a member of.");
            senderPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Вы не являетесь участником канала '" + channel.getDisplayName() + "'."));
            return;
        }

        LinkedList<ChatMessage> history = chatHistories.computeIfAbsent(chatMessage.channelId, k -> new LinkedList<>());
        synchronized (history) {
            history.add(chatMessage);
            while (history.size() > MAX_HISTORY_PER_CHANNEL) {
                history.removeFirst();
            }
        }
        chatData.updateSingleHistoryNBT(chatMessage.channelId, history);

        PacketBroadcastChatMessageToClient packet = new PacketBroadcastChatMessageToClient(chatMessage);
        MinecraftServer server = FMLCommonHandler.instance().getMinecraftServerInstance();
        if (server == null) return;

        if (channel.getType() == ChatChannelType.COMMON_SERVER_WIDE) {
            for (EntityPlayerMP p : server.getPlayerList().getPlayers()) {
                if (getKPKUserAndOwner(p) != null) {
                    PacketHandler.INSTANCE.sendTo(packet, p);
                }
            }
        } else {
            for (UUID memberUuid : channel.getMembers()) {
                EntityPlayerMP memberPlayer = server.getPlayerList().getPlayerByUUID(memberUuid);
                if (memberPlayer != null) {
                    PacketHandler.INSTANCE.sendTo(packet, memberPlayer);
                }
            }
        }
    }

    public static List<ChatMessage> getChatHistory(String channelId) {
        LinkedList<ChatMessage> history = chatHistories.get(channelId);
        if (history != null) {
            synchronized (history) {
                return new ArrayList<>(history);
            }
        }
        return Collections.emptyList();
    }

    public static void onPlayerLogin(EntityPlayerMP player) {
        if (chatData == null) {
            load(player.mcServer);
            if (chatData == null) {
                System.err.println("[ExampleMod] ChatManager.onPlayerLogin: chatData is STILL null after load. Cannot sync chat for " + player.getName());
                return;
            }
        }

        List<ChatChannel> subscribed = getSubscribedChannels(player);
        PacketHandler.INSTANCE.sendTo(new PacketSyncSubscribedChannels(subscribed), player);

        for (ChatChannel channel : subscribed) {
            List<ChatMessage> history = getChatHistory(channel.getChannelId());
            if (!history.isEmpty()) {
                PacketHandler.INSTANCE.sendTo(new PacketSyncChatHistoryToClient(channel.getChannelId(), history), player);
            }
        }
    }

    public static boolean addPlayerToGroupChannelByCallsign(String channelId, String targetCallsign, EntityPlayerMP addingPlayer) {
        if (chatData == null) return false;
        ChatChannel channel = chatData.getChannel(channelId);
        MinecraftServer server = FMLCommonHandler.instance().getMinecraftServerInstance();

        if (channel == null || channel.getType() != ChatChannelType.PRIVATE_GROUP) {
            addingPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Канал не найден или не является групповым."));
            return false;
        }

        Pair<UUID, User> adderIdentity = getKPKUserAndOwner(addingPlayer);
        if (adderIdentity == null) {
            addingPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Ваш КПК не настроен."));
            return false;
        }

        if (!channel.getCreatorUuid().equals(adderIdentity.getLeft())) {
            addingPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Только создатель канала может добавлять участников."));
            return false;
        }

        EntityPlayerMP playerToAdd = null;
        Pair<UUID, User> targetIdentity = null;
        for (EntityPlayerMP p : server.getPlayerList().getPlayers()) {
            Pair<UUID, User> identity = getKPKUserAndOwner(p);
            if (identity != null && targetCallsign.equalsIgnoreCase(identity.getRight().pozivnoy)) {
                playerToAdd = p;
                targetIdentity = identity;
                break;
            }
        }

        if (playerToAdd == null || targetIdentity == null) {
            addingPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Игрок с позывным '" + targetCallsign + "' не найден или его КПК не настроен/не в руке."));
            return false;
        }

        if (channel.isMember(targetIdentity.getLeft())) {
            addingPlayer.sendMessage(new TextComponentString(TextFormatting.YELLOW + playerToAdd.getName() + " уже в канале."));
            return false;
        }
        if (channel.getMembers().size() >= channel.getMaxMembers()) {
            addingPlayer.sendMessage(new TextComponentString(TextFormatting.RED + "Не удалось добавить " + playerToAdd.getName() + ". Канал полон."));
            return false;
        }

        channel.addMember(targetIdentity.getLeft());
        chatData.addOrUpdateChannel(channel);

        PacketNotifyChannelCreatedOrUpdated packetUpdate = new PacketNotifyChannelCreatedOrUpdated(channel);
        String notification = TextFormatting.GREEN + addingPlayer.getName() + " добавил(а) " + playerToAdd.getName() + " в ЗК '" + channel.getDisplayName() + "'.";

        for (UUID memberUuid : channel.getMembers()) {
            EntityPlayerMP memberPlayer = server.getPlayerList().getPlayerByUUID(memberUuid);
            if (memberPlayer != null) {
                PacketHandler.INSTANCE.sendTo(packetUpdate, memberPlayer);
                if (memberUuid.equals(targetIdentity.getLeft())) {
                    memberPlayer.sendMessage(new TextComponentString(TextFormatting.GREEN + addingPlayer.getName() + " добавил(а) вас в ЗК '" + channel.getDisplayName() + "'."));
                } else if(!memberUuid.equals(adderIdentity.getLeft())){
                    memberPlayer.sendMessage(new TextComponentString(notification));
                }
            }
        }
        addingPlayer.sendMessage(new TextComponentString(TextFormatting.GREEN + playerToAdd.getName() + " добавлен(а) в канал."));
        return true;
    }

    public static boolean removeMemberFromGroupChannel(String channelId, UUID memberToRemoveUuid, EntityPlayerMP requester) {
        if (chatData == null || channelId == null || memberToRemoveUuid == null || requester == null) return false;
        ChatChannel channel = chatData.getChannel(channelId);
        MinecraftServer server = requester.getServer();

        if (channel == null || channel.getType() != ChatChannelType.PRIVATE_GROUP) {
            requester.sendMessage(new TextComponentString(TextFormatting.RED + "Канал не найден или не является групповым."));
            return false;
        }

        Pair<UUID, User> requesterIdentity = getKPKUserAndOwner(requester);
        if (requesterIdentity == null) return false;

        if (channel.getCreatorUuid() == null || !channel.getCreatorUuid().equals(requesterIdentity.getLeft())) {
            requester.sendMessage(new TextComponentString(TextFormatting.RED + "Только создатель канала может исключать участников."));
            return false;
        }

        if (memberToRemoveUuid.equals(requesterIdentity.getLeft())) {
            requester.sendMessage(new TextComponentString(TextFormatting.RED + "Вы не можете исключить самого себя. Для выхода используйте кнопку удаления чата."));
            return false;
        }

        if (!channel.isMember(memberToRemoveUuid)) {
            requester.sendMessage(new TextComponentString(TextFormatting.RED + "Участник не найден в этом канале."));
            return false;
        }

        User removedUser = KPKServerManager.getUser(memberToRemoveUuid);
        String removedPlayerName = (removedUser != null) ? removedUser.pozivnoy : "???";

        channel.removeMember(memberToRemoveUuid);
        chatData.addOrUpdateChannel(channel);
        chatData.markDirty();

        requester.sendMessage(new TextComponentString(TextFormatting.GREEN + "Вы исключили " + removedPlayerName + " из канала '" + channel.getDisplayName() + "'."));

        EntityPlayerMP removedPlayer = server.getPlayerList().getPlayerByUUID(memberToRemoveUuid);
        if (removedPlayer != null) {
            removedPlayer.sendMessage(new TextComponentString(TextFormatting.YELLOW + "Вы были исключены из канала '" + channel.getDisplayName() + "'."));
            PacketHandler.INSTANCE.sendTo(new PacketNotifyChannelDeleted(channelId), removedPlayer);
        }

        PacketNotifyChannelCreatedOrUpdated packetUpdate = new PacketNotifyChannelCreatedOrUpdated(channel);
        for (UUID memberUuid : channel.getMembers()) {
            EntityPlayerMP member = server.getPlayerList().getPlayerByUUID(memberUuid);
            if (member != null) {
                if (!member.equals(requester)) {
                    member.sendMessage(new TextComponentString(TextFormatting.YELLOW + removedPlayerName + " был(а) исключен(а) из канала '" + channel.getDisplayName() + "'."));
                }
                PacketHandler.INSTANCE.sendTo(packetUpdate, member);
            }
        }
        return true;
    }

    public static class ChatWorldData extends WorldSavedData {
        private Map<String, ChatChannel> channels = new ConcurrentHashMap<>();
        private Map<String, NBTTagList> chatHistoriesNBT = new ConcurrentHashMap<>();

        public ChatWorldData(String name) {
            super(name);
        }

        public ChatWorldData(){
            super(CHAT_DATA_ID);
        }

        public void loadHistories(Map<String, LinkedList<ChatMessage>> target, int maxHistory) {
            for (Map.Entry<String, NBTTagList> entry : chatHistoriesNBT.entrySet()) {
                String channelId = entry.getKey();
                NBTTagList historyNbt = entry.getValue();
                LinkedList<ChatMessage> history = new LinkedList<>();
                for (int i = 0; i < historyNbt.tagCount(); i++) {
                    history.add(new ChatMessage(historyNbt.getCompoundTagAt(i)));
                }
                while(history.size() > maxHistory) {
                    history.removeFirst();
                }
                target.put(channelId, history);
            }
        }

        public void updateSingleHistoryNBT(String channelId, LinkedList<ChatMessage> singleHistory) {
            NBTTagList historyNbt = new NBTTagList();
            synchronized (singleHistory) {
                for (ChatMessage msg : singleHistory) {
                    historyNbt.appendTag(msg.toNBT());
                }
            }
            chatHistoriesNBT.put(channelId, historyNbt);
            markDirty();
        }

        public void saveHistories(Map<String, LinkedList<ChatMessage>> source) {
            chatHistoriesNBT.clear();
            for (Map.Entry<String, LinkedList<ChatMessage>> entry : source.entrySet()) {
                String channelId = entry.getKey();
                LinkedList<ChatMessage> history = entry.getValue();
                NBTTagList historyNbt = new NBTTagList();
                synchronized (history) {
                    for (ChatMessage msg : history) {
                        historyNbt.appendTag(msg.toNBT());
                    }
                }
                chatHistoriesNBT.put(channelId, historyNbt);
            }
            markDirty();
        }

        public ChatChannel getChannel(String channelId) {
            return channels.get(channelId);
        }

        public List<ChatChannel> getAllChannels() {
            return new ArrayList<>(channels.values());
        }

        public void addOrUpdateChannel(ChatChannel channel) {
            channels.put(channel.getChannelId(), channel);
            markDirty();
        }

        public void removeChannel(String channelId) {
            channels.remove(channelId);
            chatHistoriesNBT.remove(channelId);
            markDirty();
        }

        @Override
        public void readFromNBT(NBTTagCompound nbt) {
            NBTTagList channelsListNBT = nbt.getTagList("ChatChannels", Constants.NBT.TAG_COMPOUND);
            this.channels.clear();
            for (int i = 0; i < channelsListNBT.tagCount(); i++) {
                NBTTagCompound channelNBT = channelsListNBT.getCompoundTagAt(i);
                ChatChannel channel = ChatChannel.fromNBT(channelNBT);
                this.channels.put(channel.getChannelId(), channel);
            }

            this.chatHistoriesNBT.clear();
            if (nbt.hasKey("ChatHistories", Constants.NBT.TAG_COMPOUND)) {
                NBTTagCompound historiesRoot = nbt.getCompoundTag("ChatHistories");
                for (String channelId : historiesRoot.getKeySet()) {
                    this.chatHistoriesNBT.put(channelId, historiesRoot.getTagList(channelId, Constants.NBT.TAG_COMPOUND));
                }
            }
        }

        @Override
        public NBTTagCompound writeToNBT(NBTTagCompound nbt) {
            NBTTagList channelsListNBT = new NBTTagList();
            for (ChatChannel channel : this.channels.values()) {
                channelsListNBT.appendTag(channel.toNBT());
            }
            nbt.setTag("ChatChannels", channelsListNBT);

            NBTTagCompound historiesRoot = new NBTTagCompound();
            for (Map.Entry<String, NBTTagList> entry : this.chatHistoriesNBT.entrySet()) {
                historiesRoot.setTag(entry.getKey(), entry.getValue());
            }
            nbt.setTag("ChatHistories", historiesRoot);

            return nbt;
        }
    }
}===== com/example/examplemod/chat/ChatMessage.java =====
package com.example.examplemod.chat;

import io.netty.buffer.ByteBuf;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.common.network.ByteBufUtils;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

public class ChatMessage {
    public UUID senderUuid;
    public String senderCallsign;
    public String senderPlayerName;
    public long timestamp;
    public String messageContent;
    public String channelId;

    private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm:ss");

    public ChatMessage(UUID senderUuid, String senderCallsign, String senderPlayerName, long timestamp, String messageContent, String channelId) {
        this.senderUuid = senderUuid;
        this.senderCallsign = senderCallsign;
        this.senderPlayerName = senderPlayerName;
        this.timestamp = timestamp;
        this.messageContent = messageContent;
        this.channelId = channelId;
    }

    public ChatMessage(NBTTagCompound nbt) {
        String uuidStr = nbt.getString("senderUuid");
        if (uuidStr != null && !uuidStr.isEmpty()) {
            try {
                this.senderUuid = UUID.fromString(uuidStr);
            } catch (IllegalArgumentException e) {
                this.senderUuid = null;
            }
        } else {
            this.senderUuid = null;
        }

        this.senderCallsign = nbt.getString("senderCallsign");
        this.senderPlayerName = nbt.getString("senderPlayerName");
        this.timestamp = nbt.getLong("timestamp");
        this.messageContent = nbt.getString("messageContent");
        this.channelId = nbt.getString("channelId");
    }

    public NBTTagCompound toNBT() {
        NBTTagCompound nbt = new NBTTagCompound();
        nbt.setString("senderUuid", this.senderUuid != null ? this.senderUuid.toString() : "");
        nbt.setString("senderCallsign", this.senderCallsign);
        nbt.setString("senderPlayerName", this.senderPlayerName);
        nbt.setLong("timestamp", this.timestamp);
        nbt.setString("messageContent", this.messageContent);
        nbt.setString("channelId", this.channelId);
        return nbt;
    }

    public String getFormattedTimestamp() {
        LocalDateTime localDateTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault());
        return localDateTime.format(TIME_FORMATTER);
    }

    public static ChatMessage fromBytes(ByteBuf buf) {
        UUID senderUuid = null;
        if (buf.readBoolean()) {
            senderUuid = UUID.fromString(ByteBufUtils.readUTF8String(buf));
        }
        String senderCallsign = ByteBufUtils.readUTF8String(buf);
        String senderPlayerName = ByteBufUtils.readUTF8String(buf);
        long timestamp = buf.readLong();
        String messageContent = ByteBufUtils.readUTF8String(buf);
        String channelId = ByteBufUtils.readUTF8String(buf);
        return new ChatMessage(senderUuid, senderCallsign, senderPlayerName, timestamp, messageContent, channelId);
    }

    public void toBytes(ByteBuf buf) {
        buf.writeBoolean(senderUuid != null);
        if (senderUuid != null) {
            ByteBufUtils.writeUTF8String(buf, senderUuid.toString());
        }
        ByteBufUtils.writeUTF8String(buf, senderCallsign);
        ByteBufUtils.writeUTF8String(buf, senderPlayerName);
        buf.writeLong(timestamp);
        ByteBufUtils.writeUTF8String(buf, messageContent);
        ByteBufUtils.writeUTF8String(buf, channelId);
    }
}===== com/example/examplemod/chat/ClientChatCache.java =====
package com.example.examplemod.chat;

import com.example.examplemod.User;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.commons.lang3.tuple.Pair;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;

@SideOnly(Side.CLIENT)
public class ClientChatCache {
    private static final Map<String, LinkedList<ChatMessage>> chatHistories = new ConcurrentHashMap<>();
    private static final Map<String, ChatChannel> subscribedChannels = new ConcurrentHashMap<>();
    private static final int MAX_CLIENT_HISTORY_PER_CHANNEL = 50;

    private static final Map<UUID, String> knownCallsigns = new ConcurrentHashMap<>();
    private static final Map<UUID, User> kpkUserDatabase = new ConcurrentHashMap<>();
    public static UUID activeKpkOwnerUUID = null;

    private static final List<Runnable> onChatDataUpdatedListeners = new CopyOnWriteArrayList<>();

    public static void addOnChatDataUpdatedListener(Runnable listener) {
        if (listener != null && !onChatDataUpdatedListeners.contains(listener)) {
            onChatDataUpdatedListeners.add(listener);
        }
    }

    public static void removeOnChatDataUpdatedListener(Runnable listener) {
        onChatDataUpdatedListeners.remove(listener);
    }

    private static void notifyListeners() {
        for (Runnable listener : onChatDataUpdatedListeners) {
            listener.run();
        }
    }

    public static void addMessage(ChatMessage message) {
        if (message == null || message.channelId == null) return;

        LinkedList<ChatMessage> history = chatHistories.computeIfAbsent(message.channelId, k -> new LinkedList<>());
        synchronized (history) {
            history.add(message);
            while (history.size() > MAX_CLIENT_HISTORY_PER_CHANNEL) {
                history.removeFirst();
            }
        }
        if (message.senderUuid != null && message.senderCallsign != null) {
            knownCallsigns.put(message.senderUuid, message.senderCallsign);
        }
        notifyListeners();
    }

    public static void setHistory(String channelId, List<ChatMessage> messages) {
        if (channelId == null || messages == null) return;
        LinkedList<ChatMessage> history = new LinkedList<>(messages);
        while (history.size() > MAX_CLIENT_HISTORY_PER_CHANNEL) {
            history.removeFirst();
        }
        chatHistories.put(channelId, history);

        for (ChatMessage msg : messages) {
            if (msg.senderUuid != null && msg.senderCallsign != null) {
                knownCallsigns.put(msg.senderUuid, msg.senderCallsign);
            }
        }
        notifyListeners();
    }

    public static List<ChatMessage> getChatHistory(String channelId) {
        LinkedList<ChatMessage> history = chatHistories.get(channelId);
        if (history != null) {
            synchronized (history) {
                return new ArrayList<>(history);
            }
        }
        return Collections.emptyList();
    }

    public static void addOrUpdateChannel(ChatChannel channel) {
        if (channel == null) return;
        subscribedChannels.put(channel.getChannelId(), channel);
        chatHistories.putIfAbsent(channel.getChannelId(), new LinkedList<>());
        notifyListeners();
    }

    public static void setSubscribedChannels(List<ChatChannel> channels) {
        // ЭТО КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: ПОЛНАЯ ОЧИСТКА ПЕРЕД ОБНОВЛЕНИЕМ
        subscribedChannels.clear();
        chatHistories.clear();

        for (ChatChannel channel : channels) {
            subscribedChannels.put(channel.getChannelId(), channel);
            chatHistories.putIfAbsent(channel.getChannelId(), new LinkedList<>());
        }

        notifyListeners();
    }

    public static void removeChannel(String channelId) {
        if (channelId == null) return;
        subscribedChannels.remove(channelId);
        chatHistories.remove(channelId);
        notifyListeners();
    }

    public static ChatChannel getChannel(String channelId) {
        return subscribedChannels.get(channelId);
    }

    public static String getCallsignForUUID(UUID uuid) {
        if (uuid == null) return "???";
        if (knownCallsigns.containsKey(uuid)) {
            return knownCallsigns.get(uuid);
        }
        User user = kpkUserDatabase.get(uuid);
        if (user != null) {
            return user.pozivnoy;
        }
        return uuid.toString().substring(0, 8);
    }

    public static List<ChatChannel> getSubscribedChannels() {
        return subscribedChannels.values().stream()
                .sorted((c1, c2) -> {
                    if (c1.getType() == ChatChannelType.COMMON_SERVER_WIDE) return -1;
                    if (c2.getType() == ChatChannelType.COMMON_SERVER_WIDE) return 1;
                    if (c1.getType().ordinal() != c2.getType().ordinal()) {
                        return Integer.compare(c1.getType().ordinal(), c2.getType().ordinal());
                    }
                    return c1.getDisplayName().compareToIgnoreCase(c2.getDisplayName());
                })
                .collect(Collectors.toList());
    }

    public static void clearCache() {
        chatHistories.clear();
        subscribedChannels.clear();
        knownCallsigns.clear();
        kpkUserDatabase.clear();
        activeKpkOwnerUUID = null;
        notifyListeners();
    }

    public static void setKpkUserDatabase(Map<UUID, User> database) {
        kpkUserDatabase.clear();
        kpkUserDatabase.putAll(database);
    }

    public static UUID findUserByCallsign(String callsign) {
        if (callsign == null || callsign.isEmpty()) return null;
        for (Map.Entry<UUID, User> entry : kpkUserDatabase.entrySet()) {
            if (callsign.equalsIgnoreCase(entry.getValue().pozivnoy)) {
                return entry.getKey();
            }
        }
        return null;
    }
}===== com/example/examplemod/client/ClientEventHandler.java =====
package com.example.examplemod.client;

import com.example.examplemod.ExampleMod;
import com.example.examplemod.User;
import com.example.examplemod.chat.ClientChatCache;
import com.example.examplemod.gui.KPKModelInteractionGui;
import com.example.examplemod.item.ItemKPK;
import com.example.examplemod.network.PacketHandler;
import com.example.examplemod.network.PacketRequestChannelSync;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.UUID;

@Mod.EventBusSubscriber(modid = ExampleMod.MODID, value = Side.CLIENT)
public class ClientEventHandler {

    private static UUID lastCheckedKpkOwnerUUID = null;

    @SideOnly(Side.CLIENT)
    @SubscribeEvent
    public static void onPlayerTick(TickEvent.PlayerTickEvent event) {
        if (event.side != Side.CLIENT || event.phase != TickEvent.Phase.END) return;

        EntityPlayer player = event.player;
        if (player == null || player.world == null) return;

        // Эта проверка выполняется постоянно, а не только когда открыт GUI
        checkActiveKpkIdentity(player);

        Minecraft mc = Minecraft.getMinecraft();
        if (mc == null) return;

        if (mc.currentScreen instanceof KPKModelInteractionGui) {
            boolean holdingEnabledKPK = false;
            ItemStack kpkStackInHand = null;

            ItemStack mainHand = player.getHeldItemMainhand();
            ItemStack offHand = player.getHeldItemOffhand();

            if (mainHand.getItem() instanceof ItemKPK && ItemKPK.isEnabled(mainHand)) {
                holdingEnabledKPK = true;
                kpkStackInHand = mainHand;
            } else if (offHand.getItem() instanceof ItemKPK && ItemKPK.isEnabled(offHand)) {
                holdingEnabledKPK = true;
                kpkStackInHand = offHand;
            }

            KPKModelInteractionGui currentGui = (KPKModelInteractionGui) mc.currentScreen;
            ItemStack currentScreenStack = currentGui.getKpkStack();

            if (!holdingEnabledKPK) {
                player.closeScreen();
            } else {
                if (currentScreenStack != kpkStackInHand) {
                    player.closeScreen();
                }
            }
        }
    }

    @SideOnly(Side.CLIENT)
    private static void checkActiveKpkIdentity(EntityPlayer player) {
        ItemStack kpkStack = player.getHeldItemMainhand();
        if (!(kpkStack.getItem() instanceof ItemKPK) || !ItemKPK.isEnabled(kpkStack)) {
            kpkStack = player.getHeldItemOffhand();
            if (!(kpkStack.getItem() instanceof ItemKPK) || !ItemKPK.isEnabled(kpkStack)) {
                kpkStack = ItemStack.EMPTY;
            }
        }

        UUID currentOwnerUUID = null;
        if (!kpkStack.isEmpty()) {
            User kpkUser = ItemKPK.getUserData(kpkStack);
            if (kpkUser != null) {
                currentOwnerUUID = ClientChatCache.findUserByCallsign(kpkUser.pozivnoy);
            }
        }

        if (currentOwnerUUID == null) {
            currentOwnerUUID = player.getUniqueID();
        }

        if (lastCheckedKpkOwnerUUID == null || !lastCheckedKpkOwnerUUID.equals(currentOwnerUUID)) {
            lastCheckedKpkOwnerUUID = currentOwnerUUID;
            ClientChatCache.activeKpkOwnerUUID = currentOwnerUUID;
            PacketHandler.INSTANCE.sendToServer(new PacketRequestChannelSync());
        }
    }
}===== com/example/examplemod/client/ModelRegistryHandler.java =====
package com.example.examplemod.client;

import com.example.examplemod.ExampleMod;
import com.example.examplemod.item.ModItems;
import com.example.examplemod.item.ItemKPKRenderer;
import net.minecraft.client.renderer.block.model.ModelBakery;
import net.minecraft.client.renderer.block.model.ModelResourceLocation;
import net.minecraft.item.Item;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.client.event.ModelRegistryEvent;
import net.minecraftforge.client.model.ModelLoader;
import net.minecraftforge.client.model.obj.OBJLoader;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@Mod.EventBusSubscriber(modid = ExampleMod.MODID, value = Side.CLIENT)
public class ModelRegistryHandler {

    @SubscribeEvent
    @SideOnly(Side.CLIENT)
    public static void registerModels(ModelRegistryEvent event) {
        System.out.println("=== MODEL REGISTRATION DEBUG ===");

        OBJLoader.INSTANCE.addDomain(ExampleMod.MODID);
        System.out.println("→ OBJ Loader enabled for domain: " + ExampleMod.MODID);

        if (ModItems.KPK_DEVICE != null) {
            ModItems.KPK_DEVICE.setTileEntityItemStackRenderer(new ItemKPKRenderer());
            System.out.println("→ Set TileEntityItemStackRenderer for KPK_DEVICE");
        }

        if (ModItems.KPK_DEVICE != null && ModItems.KPK_DEVICE.getRegistryName() != null) {
            ModelResourceLocation inventoryVariant = new ModelResourceLocation(
                    ModItems.KPK_DEVICE.getRegistryName(), "inventory");
            ModelLoader.setCustomModelResourceLocation(ModItems.KPK_DEVICE, 0, inventoryVariant);
            ModelBakery.registerItemVariants(ModItems.KPK_DEVICE,
                    new ResourceLocation(ExampleMod.MODID, "kpk_device"));

            System.out.println("→ Registered KPK device model: " + inventoryVariant);
        }

        for (Item item : ModItems.ITEMS) {
            if (item == ModItems.KPK_DEVICE) continue;

            if (item.getRegistryName() == null) {
                System.err.println("Item " + item + " has null registryName! Skipping model registration.");
                continue;
            }

            ModelResourceLocation mrl = new ModelResourceLocation(item.getRegistryName(), "inventory");
            ModelLoader.setCustomModelResourceLocation(item, 0, mrl);

            System.out.println("→ Registered model for: " + item.getRegistryName());
        }

        System.out.println("Model registration complete!");
    }
}===== com/example/examplemod/ExampleMod.java =====
package com.example.examplemod;

import com.example.examplemod.chat.ChatManager;
import com.example.examplemod.command.CommandKPKSet;
import com.example.examplemod.gui.GuiHandler;
import com.example.examplemod.kpk.KPKServerManager;
import com.example.examplemod.network.PacketHandler;
import com.example.examplemod.proxy.CommonProxy;
import net.minecraft.server.MinecraftServer;
import net.minecraftforge.fml.common.FMLCommonHandler;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.Mod.EventHandler;
import net.minecraftforge.fml.common.SidedProxy;
import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.common.event.FMLServerStartingEvent;
import net.minecraftforge.fml.common.event.FMLServerStoppedEvent;
import net.minecraftforge.fml.common.network.NetworkRegistry;
import org.apache.logging.log4j.Logger;

@Mod(modid = ExampleMod.MODID, name = ExampleMod.NAME, version = ExampleMod.VERSION)
public class ExampleMod
{
    public static final String MODID = "examplemod";
    public static final String NAME = "Example Mod";
    public static final String VERSION = "1.0";
    public static ExampleMod instance;
    public static Logger logger;

    @SidedProxy(clientSide = "com.example.examplemod.proxy.ClientProxy", serverSide = "com.example.examplemod.proxy.CommonProxy")
    public static CommonProxy proxy;

    public ExampleMod() {
        instance = this;
    }

    @EventHandler
    public void preInit(FMLPreInitializationEvent event) {
        logger = event.getModLog();
        PacketHandler.init();
    }

    @EventHandler
    public void serverStarting(FMLServerStartingEvent event) {
        event.registerServerCommand(new CommandKPKSet());
        ChatManager.load(event.getServer());
        KPKServerManager.load(event.getServer());
    }

    @EventHandler
    public void serverStopped(FMLServerStoppedEvent event) {
        MinecraftServer server = FMLCommonHandler.instance().getMinecraftServerInstance();
        if (server != null) {
            ChatManager.save(server);
            KPKServerManager.save(server);
        } else {
            ExampleMod.logger.warn("Could not save data: MinecraftServer instance is null during FMLServerStoppedEvent.");
        }
    }

    @EventHandler
    public void init(FMLInitializationEvent event) {
        NetworkRegistry.INSTANCE.registerGuiHandler(instance, new GuiHandler());
    }
}===== com/example/examplemod/Gender.java =====
package com.example.examplemod;

public enum Gender {
    MALE("Мужской"),
    FEMALE("Женский");

    private final String displayName;

    Gender(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }

    public static Gender fromString(String text) {
        if (text != null) {
            for (Gender g : Gender.values()) {
                if (text.equalsIgnoreCase(g.name()) || text.equalsIgnoreCase("м") && g == MALE ||
                        text.equalsIgnoreCase("ж") && g == FEMALE) {
                    return g;
                }
            }
        }
        return null;
    }
}===== com/example/examplemod/gui/GuiHandler.java =====
package com.example.examplemod.gui;

import com.example.examplemod.ExampleMod;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.network.IGuiHandler;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.annotation.Nullable;
import java.util.function.Consumer;

public class GuiHandler implements IGuiHandler {
    public static final int KPK_MODEL_INTERACTION_GUI_ID = 0;
    public static final int KPK_MAIN_GUI_ID = 1;
    public static final int TEXT_INPUT_GUI_ID = 2;

    public static String textInputTitle;
    public static Consumer<String> textInputCallback;
    public static GuiScreen textInputParent;

    @Nullable
    @Override
    public Object getServerGuiElement(int ID, EntityPlayer player, World world, int x, int y, int z) {
        return null;
    }

    @Nullable
    @Override
    @SideOnly(Side.CLIENT)
    public Object getClientGuiElement(int ID, EntityPlayer player, World world, int x, int y, int z) {
        switch (ID) {
            case KPK_MODEL_INTERACTION_GUI_ID:
                return new KPKModelInteractionGui();
            case KPK_MAIN_GUI_ID:
                return new KPKGui();
            case TEXT_INPUT_GUI_ID:
                return new GuiTextInput(textInputParent, textInputTitle, textInputCallback);
            default:
                return null;
        }
    }
}===== com/example/examplemod/gui/GuiSelectPlayerForChat.java =====
package com.example.examplemod.gui;

import com.example.examplemod.item.ItemKPK;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiButton;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import org.lwjgl.input.Mouse;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

public class GuiSelectPlayerForChat extends GuiScreen {
    protected GuiScreen parentScreen;
    protected String title;
    protected Consumer<List<String>> onConfirm;
    protected int maxSelections;

    private List<String> availableContacts;
    private List<String> selectedContacts;

    private GuiButton doneButton;
    private GuiButton cancelButton;

    private int listTop, listBottom, slotHeight;
    private int scrollOffset = 0;
    private int maxVisibleSlots = 0;

    private final int COLOR_BACKGROUND = 0xFF1E1E1E;
    private final int COLOR_LIST_BG = 0x99000000;
    private final int COLOR_LIST_BORDER = 0xFF000000;
    private final int COLOR_SCROLLBAR = 0xFF888888;
    private final int COLOR_SELECTED_ITEM = 0x80FFAA00;
    private final int COLOR_TITLE = 0xFFFFAA00;
    private final int COLOR_TEXT_NORMAL = 0xFFD0D0D0;
    private final int COLOR_TEXT_SELECTED = 0xFFFFFFFF;
    private final int COLOR_TEXT_HINT = 0xFF888888;

    public GuiSelectPlayerForChat(GuiScreen parent, String title, Consumer<List<String>> onConfirm, int maxSelections) {
        this.parentScreen = parent;
        this.title = title;
        this.onConfirm = onConfirm;
        this.maxSelections = maxSelections;
        this.selectedContacts = new ArrayList<>();

        EntityPlayer player = Minecraft.getMinecraft().player;
        if (player != null) {
            ItemStack kpkStack = player.getHeldItemMainhand();
            if (!(kpkStack.getItem() instanceof ItemKPK)) {
                kpkStack = player.getHeldItemOffhand();
            }

            if (kpkStack.getItem() instanceof ItemKPK) {
                this.availableContacts = ItemKPK.getContacts(kpkStack);
            } else {
                this.availableContacts = new ArrayList<>();
            }
        } else {
            this.availableContacts = new ArrayList<>();
        }
    }

    @Override
    public void initGui() {
        this.buttonList.clear();
        this.doneButton = this.addButton(new GuiButton(0, this.width / 2 - 154, this.height - 38, 150, 20, "Готово"));
        this.cancelButton = this.addButton(new GuiButton(1, this.width / 2 + 4, this.height - 38, 150, 20, "Отмена"));

        this.listTop = 32;
        this.listBottom = this.height - 64;
        this.slotHeight = fontRenderer.FONT_HEIGHT + 6;
        this.maxVisibleSlots = (this.listBottom - this.listTop) / this.slotHeight;

        updateDoneButtonState();
    }

    private void updateDoneButtonState() {
        this.doneButton.enabled = !this.selectedContacts.isEmpty();
    }

    @Override
    protected void actionPerformed(GuiButton button) throws IOException {
        if (button.enabled) {
            if (button.id == 0) {
                this.onConfirm.accept(new ArrayList<>(this.selectedContacts));
                this.mc.displayGuiScreen(this.parentScreen);
            } else if (button.id == 1) {
                this.mc.displayGuiScreen(this.parentScreen);
            }
        }
    }

    @Override
    public void handleMouseInput() throws IOException {
        super.handleMouseInput();
        int dWheel = Mouse.getEventDWheel();
        if (dWheel != 0 && availableContacts.size() > maxVisibleSlots) {
            if (dWheel > 0) {
                scrollOffset = Math.max(0, scrollOffset - 1);
            } else {
                scrollOffset = Math.min(availableContacts.size() - maxVisibleSlots, scrollOffset + 1);
            }
        }
    }


    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks) {
        drawRect(0, 0, this.width, this.height, COLOR_BACKGROUND);
        this.drawCenteredString(this.fontRenderer, this.title, this.width / 2, 15, COLOR_TITLE);

        int listLeft = this.width / 2 - 120;
        int listWidth = 240;

        drawRect(listLeft - 1, listTop - 1, listLeft + listWidth + 1, listBottom + 1, COLOR_LIST_BORDER);
        drawRect(listLeft, listTop, listLeft + listWidth, listBottom, COLOR_LIST_BG);

        for (int i = 0; i < maxVisibleSlots; i++) {
            int contactIndex = i + scrollOffset;
            if (contactIndex >= 0 && contactIndex < availableContacts.size()) {
                String contactCallsign = availableContacts.get(contactIndex);
                boolean isSelected = selectedContacts.contains(contactCallsign);

                int itemY = listTop + i * slotHeight;

                if (isSelected) {
                    drawRect(listLeft, itemY, listLeft + listWidth, itemY + slotHeight, COLOR_SELECTED_ITEM);
                }

                String displayString = contactCallsign;
                this.fontRenderer.drawString(displayString, listLeft + 5, itemY + 4, isSelected ? COLOR_TEXT_SELECTED : COLOR_TEXT_NORMAL);
            }
        }

        if (availableContacts.size() > maxVisibleSlots) {
            int scrollBarHeight = Math.max(10, (int) ((float) maxVisibleSlots / availableContacts.size() * (listBottom - listTop)));
            int scrollBarY = listTop + (int) ((float) scrollOffset / (availableContacts.size() - maxVisibleSlots) * ((listBottom - listTop) - scrollBarHeight));
            drawRect(listLeft + listWidth + 2, scrollBarY, listLeft + listWidth + 5, scrollBarY + scrollBarHeight, COLOR_SCROLLBAR);
        }


        super.drawScreen(mouseX, mouseY, partialTicks);
        if (maxSelections > 1) {
            this.drawCenteredString(this.fontRenderer, "Выбрано: " + selectedContacts.size() + "/" + maxSelections, this.width/2, this.height - 52, COLOR_TEXT_HINT);
        }
    }

    @Override
    protected void mouseClicked(int mouseX, int mouseY, int mouseButton) throws IOException {
        super.mouseClicked(mouseX, mouseY, mouseButton);
        if (mouseButton == 0) {
            int listLeft = this.width / 2 - 120;
            int listWidth = 240;

            if (mouseX >= listLeft && mouseX <= listLeft + listWidth && mouseY >= listTop && mouseY <= listBottom) {
                int slotIndex = (mouseY - listTop) / slotHeight;
                int contactIndex = slotIndex + scrollOffset;

                if (contactIndex >= 0 && contactIndex < availableContacts.size()) {
                    String clickedCallsign = availableContacts.get(contactIndex);
                    if (selectedContacts.contains(clickedCallsign)) {
                        selectedContacts.remove(clickedCallsign);
                    } else {
                        if (selectedContacts.size() < maxSelections) {
                            selectedContacts.add(clickedCallsign);
                        } else if (maxSelections == 1) {
                            selectedContacts.clear();
                            selectedContacts.add(clickedCallsign);
                        }
                    }
                    updateDoneButtonState();
                }
            }
        }
    }
}===== com/example/examplemod/gui/GuiTextInput.java =====
package com.example.examplemod.gui;

import net.minecraft.client.gui.GuiButton;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.gui.GuiTextField;
import org.lwjgl.input.Keyboard;

import java.io.IOException;
import java.util.function.Consumer;

public class GuiTextInput extends GuiScreen {
    protected GuiScreen parentScreen;
    protected String title;
    protected Consumer<String> onConfirm;

    private GuiTextField inputField;
    private GuiButton doneButton;

    private final int COLOR_BACKGROUND = 0xFF1E1E1E;
    private final int COLOR_TITLE = 0xFFFFAA00;
    private final int COLOR_INPUT_BG = 0xFF000000;
    private final int COLOR_INPUT_BORDER = 0xFF555555;

    public GuiTextInput(GuiScreen parent, String title, Consumer<String> onConfirm) {
        this.parentScreen = parent;
        this.title = title;
        this.onConfirm = onConfirm;
    }

    @Override
    public void initGui() {
        Keyboard.enableRepeatEvents(true);
        this.buttonList.clear();

        this.doneButton = this.addButton(new GuiButton(0, this.width / 2 - 100, this.height / 2 + 25, "Готово"));
        this.buttonList.add(new GuiButton(1, this.width / 2 - 100, this.height / 2 + 50, "Отмена"));

        this.inputField = new GuiTextField(2, this.fontRenderer, this.width / 2 - 100, this.height / 2 - 20, 200, 20);
        this.inputField.setMaxStringLength(35);
        this.inputField.setFocused(true);
        this.inputField.setEnableBackgroundDrawing(false);

        updateDoneButtonState();
    }

    @Override
    public void onGuiClosed() {
        Keyboard.enableRepeatEvents(false);
    }

    @Override
    public void updateScreen() {
        this.inputField.updateCursorCounter();
        updateDoneButtonState();
    }

    private void updateDoneButtonState() {
        this.doneButton.enabled = !this.inputField.getText().trim().isEmpty();
    }

    @Override
    protected void actionPerformed(GuiButton button) throws IOException {
        if (button.enabled) {
            if (button.id == 0) {
                this.onConfirm.accept(this.inputField.getText().trim());
                this.mc.displayGuiScreen(this.parentScreen);
            } else if (button.id == 1) {
                this.mc.displayGuiScreen(this.parentScreen);
            }
        }
    }

    @Override
    protected void keyTyped(char typedChar, int keyCode) throws IOException {
        this.inputField.textboxKeyTyped(typedChar, keyCode);
        if (keyCode == Keyboard.KEY_RETURN && this.doneButton.enabled) {
            this.actionPerformed(this.doneButton);
        } else if (keyCode == Keyboard.KEY_ESCAPE) {
            this.mc.displayGuiScreen(this.parentScreen);
        }
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks) {
        drawRect(0, 0, this.width, this.height, COLOR_BACKGROUND);
        this.drawCenteredString(this.fontRenderer, this.title, this.width / 2, this.height / 2 - 40, COLOR_TITLE);

        drawRect(this.inputField.x - 1, this.inputField.y - 1, this.inputField.x + this.inputField.width + 1, this.inputField.y + this.inputField.height + 1, COLOR_INPUT_BORDER);
        drawRect(this.inputField.x, this.inputField.y, this.inputField.x + this.inputField.width, this.inputField.y + this.inputField.height, COLOR_INPUT_BG);
        this.inputField.drawTextBox();

        super.drawScreen(mouseX, mouseY, partialTicks);
    }
}===== com/example/examplemod/gui/KPKGui.java =====
package com.example.examplemod.gui;

import com.example.examplemod.User;
import com.example.examplemod.chat.ChatChannel;
import com.example.examplemod.chat.ChatMessage;
import com.example.examplemod.chat.ClientChatCache;
import com.example.examplemod.item.ItemKPK;
import com.example.examplemod.network.PacketChatMessageToServer;
import com.example.examplemod.network.PacketHandler;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiButton;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.gui.GuiTextField;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.util.text.TextFormatting;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.Gui;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.GL11;

import java.io.IOException;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

public class KPKGui extends GuiScreen {
    private User userData;
    private ItemStack kpkStack;
    private static final int GUI_VIRTUAL_WIDTH = 256;
    private static final int GUI_VIRTUAL_HEIGHT = 160;

    private int currentMainPage = ItemKPK.PAGE_INFO;

    private GuiButtonCustom infoButton;
    private GuiButtonCustom chatButton;

    private static final int SUBPAGE_CHAT_COMMON = 10;
    private static final int SUBPAGE_CHAT_CREATE = 11;
    private int currentChatSubPage = SUBPAGE_CHAT_COMMON;

    private GuiButtonCustom chatCommonButton;
    private GuiButtonCustom chatCreateButton;

    private GuiTextField chatInputField;
    private GuiButtonCustom sendChatButton;
    private List<String> formattedChatMessages = new ArrayList<>();
    private int chatScrollOffset = 0;
    private int maxVisibleChatLines = 0;

    private static final int CHAT_LINE_HEIGHT = 9;
    private static final int CHAT_INPUT_HEIGHT = 18;
    private static final float CHAT_TEXT_SCALE = 1.0f;

    private final int COLOR_BG = 0xEE1A1A1A;
    private final int COLOR_TITLE = 0xFFFFAA00;
    private final int COLOR_TEXT_LABEL = 0xFFAAAAAA;
    private final int COLOR_TEXT_VALUE = 0xFFE0E0E0;
    private final int COLOR_CHAT_BG = 0x99000000;
    private final int COLOR_SCROLLBAR = 0xFF888888;


    public KPKGui() {
        EntityPlayer player = Minecraft.getMinecraft().player;
        if (player != null) {
            ItemStack heldItem = player.getHeldItemMainhand();
            if (!(heldItem.getItem() instanceof ItemKPK)) {
                heldItem = player.getHeldItemOffhand();
            }
            if (heldItem.getItem() instanceof ItemKPK) {
                this.kpkStack = heldItem;
                this.userData = ItemKPK.getUserData(this.kpkStack);
            } else {
                this.kpkStack = ItemStack.EMPTY;
                this.userData = null;
            }
        }
        ClientChatCache.addOnChatDataUpdatedListener(this::refreshChatMessages);
        refreshChatMessages();
    }

    private void scrollToBottom() {
        if (maxVisibleChatLines > 0 && formattedChatMessages.size() > maxVisibleChatLines) {
            this.chatScrollOffset = formattedChatMessages.size() - maxVisibleChatLines;
        } else {
            this.chatScrollOffset = 0;
        }
    }


    private void refreshChatMessages() {
        if (currentMainPage == ItemKPK.PAGE_CHAT && currentChatSubPage == SUBPAGE_CHAT_COMMON) {
            boolean wasScrolledToBottom = maxVisibleChatLines <= 0 || (chatScrollOffset >= formattedChatMessages.size() - maxVisibleChatLines -1);

            formattedChatMessages.clear();
            List<ChatMessage> messages = ClientChatCache.getChatHistory(ChatChannel.COMMON_CHANNEL_ID_PREFIX);

            int contentAreaX = 10 + 55 + 5;
            int chatDisplayWidth = GUI_VIRTUAL_WIDTH - contentAreaX - 10;
            int effectiveWrappingWidth = (int)(chatDisplayWidth / CHAT_TEXT_SCALE);

            for (ChatMessage msg : messages) {
                String prefix = TextFormatting.DARK_AQUA + "[" + msg.getFormattedTimestamp() + "] ";
                String senderFormatted = TextFormatting.AQUA + msg.senderPlayerName + TextFormatting.WHITE + ": ";
                String contentFormatted = msg.messageContent;

                int wrappingWidth = effectiveWrappingWidth - fontRenderer.getStringWidth(prefix) - 4;
                List<String> wrappedLines = fontRenderer.listFormattedStringToWidth(senderFormatted + contentFormatted, wrappingWidth);

                for(int i=0; i<wrappedLines.size(); ++i){
                    if(i==0){
                        formattedChatMessages.add(prefix + wrappedLines.get(i));
                    } else {
                        formattedChatMessages.add(fontRenderer.trimStringToWidth(" ", fontRenderer.getStringWidth(prefix)) + wrappedLines.get(i));
                    }
                }
            }

            if (wasScrolledToBottom) {
                scrollToBottom();
            } else {
                if (maxVisibleChatLines > 0 && chatScrollOffset > formattedChatMessages.size() - maxVisibleChatLines) {
                    chatScrollOffset = Math.max(0, formattedChatMessages.size() - maxVisibleChatLines);
                }
            }
        }
    }

    @Override
    public void initGui() {
        super.initGui();
        this.buttonList.clear();
        Keyboard.enableRepeatEvents(true);

        int buttonWidth = 55;
        int buttonHeight = 20;
        int buttonXOffset = 10;
        int buttonYStart = 15;
        int buttonSpacing = 5;

        infoButton = new GuiButtonCustom(ItemKPK.PAGE_INFO, buttonXOffset, buttonYStart, buttonWidth, buttonHeight, "ИНФРА");
        chatButton = new GuiButtonCustom(ItemKPK.PAGE_CHAT, buttonXOffset, buttonYStart + (buttonHeight + buttonSpacing), buttonWidth, buttonHeight, "ЧАТ");

        this.buttonList.add(infoButton);
        this.buttonList.add(chatButton);

        int subMenuYStart = buttonYStart + (buttonHeight + buttonSpacing) * 2 + 15;
        chatCommonButton = new GuiButtonCustom(SUBPAGE_CHAT_COMMON, buttonXOffset, subMenuYStart, buttonWidth, buttonHeight, "Общий");
        chatCreateButton = new GuiButtonCustom(SUBPAGE_CHAT_CREATE, buttonXOffset, subMenuYStart + buttonHeight + buttonSpacing, buttonWidth, buttonHeight, "Создать");

        this.buttonList.add(chatCommonButton);
        this.buttonList.add(chatCreateButton);

        chatInputField = new GuiTextField(300, this.fontRenderer, 0, 0, 100, CHAT_INPUT_HEIGHT - 2);
        chatInputField.setMaxStringLength(256);
        chatInputField.setEnableBackgroundDrawing(false);

        sendChatButton = new GuiButtonCustom(301, 0, 0, 40, CHAT_INPUT_HEIGHT - 2, "Отпр.");
        this.buttonList.add(sendChatButton);


        updateButtonStatesAndVisibility();
        refreshChatMessages();
    }

    @Override
    public void onGuiClosed() {
        super.onGuiClosed();
        Keyboard.enableRepeatEvents(false);
        ClientChatCache.removeOnChatDataUpdatedListener(this::refreshChatMessages);
    }

    @Override
    public void updateScreen() {
        super.updateScreen();
        if (chatInputField != null) {
            chatInputField.updateCursorCounter();
        }
    }

    private void updateButtonStatesAndVisibility() {
        infoButton.setActive(currentMainPage == ItemKPK.PAGE_INFO);
        chatButton.setActive(currentMainPage == ItemKPK.PAGE_CHAT);

        boolean chatPageActive = (currentMainPage == ItemKPK.PAGE_CHAT);
        chatCommonButton.visible = chatPageActive;
        chatCreateButton.visible = chatPageActive;

        chatInputField.setVisible(chatPageActive && currentChatSubPage == SUBPAGE_CHAT_COMMON);
        sendChatButton.visible = chatPageActive && currentChatSubPage == SUBPAGE_CHAT_COMMON;

        if (chatPageActive) {
            chatCommonButton.setActive(currentChatSubPage == SUBPAGE_CHAT_COMMON);
            chatCreateButton.setActive(currentChatSubPage == SUBPAGE_CHAT_CREATE);
        }
    }

    @Override
    protected void actionPerformed(GuiButton guibutton) throws IOException {
        if (guibutton.enabled || (guibutton instanceof GuiButtonCustom && ((GuiButtonCustom)guibutton).isActive())) {
            if (guibutton instanceof GuiButtonCustom && ((GuiButtonCustom)guibutton).isActive()){
                return;
            } else if (guibutton.id == ItemKPK.PAGE_INFO || guibutton.id == ItemKPK.PAGE_CHAT ) {
                if (this.currentMainPage != guibutton.id) {
                    this.currentMainPage = guibutton.id;
                    refreshChatMessages();
                    if (this.currentMainPage == ItemKPK.PAGE_CHAT) {
                        scrollToBottom();
                    } else {
                        this.chatScrollOffset = 0;
                    }
                }
            } else if (guibutton.id == SUBPAGE_CHAT_COMMON || guibutton.id == SUBPAGE_CHAT_CREATE) {
                if (this.currentMainPage == ItemKPK.PAGE_CHAT && this.currentChatSubPage != guibutton.id) {
                    this.currentChatSubPage = guibutton.id;
                    refreshChatMessages();
                    if (this.currentChatSubPage == SUBPAGE_CHAT_COMMON) {
                        scrollToBottom();
                    } else {
                        this.chatScrollOffset = 0;
                    }
                }
            } else if (guibutton == sendChatButton) {
                if (currentMainPage == ItemKPK.PAGE_CHAT && currentChatSubPage == SUBPAGE_CHAT_COMMON &&
                        chatInputField != null && !chatInputField.getText().trim().isEmpty()) {
                    PacketHandler.INSTANCE.sendToServer(new PacketChatMessageToServer(ChatChannel.COMMON_CHANNEL_ID_PREFIX, chatInputField.getText().trim()));
                    chatInputField.setText("");
                }
            }
            updateButtonStatesAndVisibility();
        }
    }

    @Override
    protected void keyTyped(char typedChar, int keyCode) throws IOException {
        if (chatInputField.isFocused()) {
            if (keyCode == Keyboard.KEY_ESCAPE) {
                chatInputField.setFocused(false);
                return;
            }
            chatInputField.textboxKeyTyped(typedChar, keyCode);
            if (keyCode == Keyboard.KEY_RETURN) {
                actionPerformed(sendChatButton);
            }
            return;
        }
        super.keyTyped(typedChar, keyCode);
    }

    @Override
    protected void mouseClicked(int mouseX, int mouseY, int mouseButton) throws IOException {
        super.mouseClicked(mouseX, mouseY, mouseButton);

        float scale = Math.min((float)this.width / GUI_VIRTUAL_WIDTH, (float)this.height / GUI_VIRTUAL_HEIGHT);
        int guiLeft = (this.width - (int)(GUI_VIRTUAL_WIDTH * scale)) / 2;
        int guiTop = (this.height - (int)(GUI_VIRTUAL_HEIGHT * scale)) / 2;
        int scaledMouseX = (int)((mouseX - guiLeft) / scale);
        int scaledMouseY = (int)((mouseY - guiTop) / scale);

        if (chatInputField.getVisible()) {
            chatInputField.mouseClicked(scaledMouseX, scaledMouseY, mouseButton);
        }
    }

    @Override
    public void handleMouseInput() throws IOException {
        super.handleMouseInput();
        int dWheel = Mouse.getEventDWheel();
        if (dWheel != 0 && currentMainPage == ItemKPK.PAGE_CHAT && currentChatSubPage == SUBPAGE_CHAT_COMMON) {
            if (dWheel > 0) {
                chatScrollOffset = Math.max(0, chatScrollOffset - 3);
            } else {
                if (maxVisibleChatLines < formattedChatMessages.size()) {
                    chatScrollOffset = Math.min(formattedChatMessages.size() - maxVisibleChatLines, chatScrollOffset + 3);
                }
            }
        }
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks) {
        if (currentMainPage == ItemKPK.PAGE_CHAT && currentChatSubPage == SUBPAGE_CHAT_COMMON) {
            refreshChatMessages();
        }

        GlStateManager.pushMatrix();

        float scale = Math.min((float)this.width / GUI_VIRTUAL_WIDTH, (float)this.height / GUI_VIRTUAL_HEIGHT);
        int guiLeft = (this.width - (int)(GUI_VIRTUAL_WIDTH * scale)) / 2;
        int guiTop = (this.height - (int)(GUI_VIRTUAL_HEIGHT * scale)) / 2;

        GlStateManager.translate(guiLeft, guiTop, 0);
        GlStateManager.scale(scale, scale, 1.0F);

        Gui.drawRect(0, 0, GUI_VIRTUAL_WIDTH, GUI_VIRTUAL_HEIGHT, COLOR_BG);

        int contentAreaX = 10 + 55 + 5;
        int contentAreaY = 15;
        int lineHeight = fontRenderer.FONT_HEIGHT + 2;

        if (userData != null || currentMainPage == ItemKPK.PAGE_CHAT) {
            String pageTitle = "";
            if (currentMainPage == ItemKPK.PAGE_INFO) pageTitle = "Персональные данные";
            else if (currentMainPage == ItemKPK.PAGE_CHAT) pageTitle = "Канал связи";

            this.fontRenderer.drawString(TextFormatting.GOLD + pageTitle, contentAreaX, contentAreaY, COLOR_TITLE);

            int mainContentY = contentAreaY + lineHeight + 4;

            if (currentMainPage == ItemKPK.PAGE_INFO) {
                if (userData != null) {
                    drawString(this.fontRenderer, "Владелец:", contentAreaX, mainContentY, COLOR_TEXT_LABEL);
                    drawString(this.fontRenderer, TextFormatting.WHITE + userData.familiya + " " + userData.name, contentAreaX + 5, mainContentY + lineHeight, COLOR_TEXT_VALUE);

                    drawString(this.fontRenderer, "Позывной:", contentAreaX, mainContentY + lineHeight * 2, COLOR_TEXT_LABEL);
                    drawString(this.fontRenderer, TextFormatting.WHITE + userData.pozivnoy, contentAreaX + 5, mainContentY + lineHeight * 3, COLOR_TEXT_VALUE);

                    drawString(this.fontRenderer, "Дата рождения:", contentAreaX, mainContentY + lineHeight * 4, COLOR_TEXT_LABEL);
                    drawString(this.fontRenderer, TextFormatting.WHITE + userData.birthdate.format(DateTimeFormatter.ofPattern("dd.MM.yyyy")), contentAreaX + 5, mainContentY + lineHeight * 5, COLOR_TEXT_VALUE);

                    drawString(this.fontRenderer, "Пол:", contentAreaX, mainContentY + lineHeight * 6, COLOR_TEXT_LABEL);
                    drawString(this.fontRenderer, TextFormatting.WHITE + userData.gender.getDisplayName(), contentAreaX + 5, mainContentY + lineHeight * 7, COLOR_TEXT_VALUE);
                } else {
                    int textWidth = this.fontRenderer.getStringWidth("КПК НЕ ИНИЦИАЛИЗИРОВАН");
                    drawString(this.fontRenderer, "КПК НЕ ИНИЦИАЛИЗИРОВАН", contentAreaX + (GUI_VIRTUAL_WIDTH - contentAreaX - 10 - textWidth)/2 , GUI_VIRTUAL_HEIGHT / 2 - 20, 0xFF5555);
                }

            } else if (currentMainPage == ItemKPK.PAGE_CHAT) {
                if (currentChatSubPage == SUBPAGE_CHAT_COMMON) {
                    int chatDisplayWidth = GUI_VIRTUAL_WIDTH - contentAreaX - 10;
                    int chatDisplayHeight = GUI_VIRTUAL_HEIGHT - mainContentY - 10 - CHAT_INPUT_HEIGHT - 3;
                    maxVisibleChatLines = (int)(chatDisplayHeight / (CHAT_LINE_HEIGHT * CHAT_TEXT_SCALE));

                    Gui.drawRect(contentAreaX, mainContentY, contentAreaX + chatDisplayWidth, mainContentY + chatDisplayHeight, COLOR_CHAT_BG);

                    GL11.glEnable(GL11.GL_SCISSOR_TEST);
                    int scissorX = guiLeft + (int)(contentAreaX * scale);
                    int scissorY = mc.displayHeight - (guiTop + (int)((mainContentY + chatDisplayHeight) * scale));
                    int scissorWidth = (int)(chatDisplayWidth * scale);
                    int scissorHeight = (int)(chatDisplayHeight * scale);
                    GL11.glScissor(scissorX, scissorY, scissorWidth, scissorHeight);

                    for (int i = 0; i < maxVisibleChatLines; i++) {
                        int messageIndex = i + chatScrollOffset;
                        if (messageIndex >= 0 && messageIndex < formattedChatMessages.size()) {
                            String msgLine = formattedChatMessages.get(messageIndex);
                            GlStateManager.pushMatrix();
                            float xPos = contentAreaX + 2;
                            float yPos = mainContentY + 2 + (i * CHAT_LINE_HEIGHT * CHAT_TEXT_SCALE);
                            GlStateManager.translate(xPos, yPos, 0f);
                            GlStateManager.scale(CHAT_TEXT_SCALE, CHAT_TEXT_SCALE, CHAT_TEXT_SCALE);
                            fontRenderer.drawStringWithShadow(msgLine, 0, 0, 0xFFFFFF);
                            GlStateManager.popMatrix();
                        }
                    }
                    GL11.glDisable(GL11.GL_SCISSOR_TEST);

                    if (formattedChatMessages.size() > maxVisibleChatLines) {
                        int scrollBarTotalHeight = chatDisplayHeight - 2;
                        int scrollBarActualHeight = Math.max(10, (int) ((float) maxVisibleChatLines / formattedChatMessages.size() * scrollBarTotalHeight));
                        int scrollBarYOffset = 0;
                        if (formattedChatMessages.size() - maxVisibleChatLines > 0) {
                            scrollBarYOffset = (int) ((float) chatScrollOffset / (formattedChatMessages.size() - maxVisibleChatLines) * (scrollBarTotalHeight - scrollBarActualHeight));
                        }
                        Gui.drawRect(contentAreaX + chatDisplayWidth - 4, mainContentY + 1 + scrollBarYOffset,
                                contentAreaX + chatDisplayWidth - 1, mainContentY + 1 + scrollBarYOffset + scrollBarActualHeight,
                                COLOR_SCROLLBAR);
                    }

                    int inputAreaY = mainContentY + chatDisplayHeight + 3;
                    chatInputField.x = contentAreaX;
                    chatInputField.y = inputAreaY;
                    chatInputField.width = chatDisplayWidth - sendChatButton.width - 2;
                    chatInputField.height = CHAT_INPUT_HEIGHT - 2;
                    if(chatInputField.getVisible()) {
                        drawRect(chatInputField.x-1, chatInputField.y-1, chatInputField.x+chatInputField.width+1, chatInputField.y+chatInputField.height+1, 0xFF000000);
                        drawRect(chatInputField.x, chatInputField.y, chatInputField.x+chatInputField.width, chatInputField.y+chatInputField.height, 0xFF333333);
                        chatInputField.drawTextBox();
                    }

                    sendChatButton.x = contentAreaX + chatDisplayWidth - sendChatButton.width;
                    sendChatButton.y = inputAreaY;

                } else if (currentChatSubPage == SUBPAGE_CHAT_CREATE) {
                    drawString(this.fontRenderer, "Создание нового чата...", contentAreaX, mainContentY, 0xFFFF55);
                }
            }
        } else {
            int textWidth = this.fontRenderer.getStringWidth("КПК НЕ ИНИЦИАЛИЗИРОВАН");
            drawString(this.fontRenderer, "КПК НЕ ИНИЦИАЛИЗИРОВАН", (GUI_VIRTUAL_WIDTH - textWidth) / 2, GUI_VIRTUAL_HEIGHT / 2 - 20, 0xFF5555);
            textWidth = this.fontRenderer.getStringWidth("Используйте команду /kpk set");
            drawString(this.fontRenderer, "Используйте команду /kpk set", (GUI_VIRTUAL_WIDTH - textWidth) / 2, GUI_VIRTUAL_HEIGHT / 2, 0xFFFF55);
        }

        for (GuiButton guibutton : this.buttonList) {
            guibutton.drawButton(this.mc, mouseX, mouseY, partialTicks);
        }

        GlStateManager.popMatrix();
    }

    @Override
    public boolean doesGuiPauseGame() {
        return false;
    }

    public static class GuiButtonCustom extends GuiButton {
        private boolean isActive = false;

        public GuiButtonCustom(int buttonId, int x, int y, int widthIn, int heightIn, String buttonText) {
            super(buttonId, x, y, widthIn, heightIn, buttonText);
        }

        public void setActive(boolean active) {
            this.isActive = active;
        }

        public boolean isActive() { return this.isActive; }

        @Override
        public void drawButton(Minecraft mc, int mouseX, int mouseY, float partialTicks) {
            if (this.visible) {
                FontRenderer fontrenderer = mc.fontRenderer;

                float guiScaleFactor = Math.min((float)mc.currentScreen.width / GUI_VIRTUAL_WIDTH, (float)mc.currentScreen.height / GUI_VIRTUAL_HEIGHT);
                int guiLeft = (mc.currentScreen.width - (int)(GUI_VIRTUAL_WIDTH * guiScaleFactor)) / 2;
                int guiTop = (mc.currentScreen.height - (int)(GUI_VIRTUAL_HEIGHT * guiScaleFactor)) / 2;

                int scaledMouseX = (int)((mouseX - guiLeft) / guiScaleFactor);
                int scaledMouseY = (int)((mouseY - guiTop) / guiScaleFactor);

                this.hovered = scaledMouseX >= this.x && scaledMouseY >= this.y && scaledMouseX < this.x + this.width && scaledMouseY < this.y + this.height;

                int bgColor;
                int borderColor;

                if (isActive) {
                    bgColor = 0xFF101010;
                    borderColor = 0xFFFFAA00;
                } else if (this.hovered && this.enabled) {
                    bgColor = 0xFF3c3c3c;
                    borderColor = 0xFF666666;
                } else {
                    bgColor = 0xFF2b2b2b;
                    borderColor = 0xFF444444;
                }

                drawRect(this.x, this.y, this.x + this.width, this.y + this.height, borderColor);
                drawRect(this.x + 1, this.y + 1, this.x + this.width - 1, this.y + this.height - 1, bgColor);

                int textColor;
                if (!this.enabled) {
                    textColor = 0xA0A0A0;
                } else if (this.isActive) {
                    textColor = 0xFFFFAA00;
                } else if (this.hovered) {
                    textColor = 0xFFFFFFA0;
                } else {
                    textColor = 0xE0E0E0;
                }
                this.drawCenteredString(fontrenderer, this.displayString, this.x + this.width / 2, this.y + (this.height - 8) / 2, textColor);
            }
        }
    }
}===== com/example/examplemod/gui/KPKModelInteractionGui.java =====
package com.example.examplemod.gui;

import com.example.examplemod.ExampleMod;
import com.example.examplemod.item.ItemKPK;
import com.example.examplemod.item.ItemKPKRenderer;
import com.example.examplemod.network.*;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.item.ItemStack;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;

import java.awt.Rectangle;
import java.io.IOException;
import java.util.List;
import java.util.UUID;

public class KPKModelInteractionGui extends GuiScreen {

    private ItemStack kpkStack;

    private boolean isAddingContact = false;

    private String currentContactInput = "";
    private boolean contactInputActive = false;
    private String currentChatInput = "";
    private boolean chatInputActive = false;
    private int cursorCounter = 0;
    public int chatScrollOffset = 0;
    public int channelScrollOffset = 0;

    public KPKModelInteractionGui() {
        super();
        if (Minecraft.getMinecraft().player != null) {
            ItemStack mainHandStack = Minecraft.getMinecraft().player.getHeldItemMainhand();
            ItemStack offHandStack = Minecraft.getMinecraft().player.getHeldItemOffhand();

            if (mainHandStack.getItem() instanceof ItemKPK) {
                this.kpkStack = mainHandStack;
            } else if (offHandStack.getItem() instanceof ItemKPK) {
                this.kpkStack = offHandStack;
            }
        }
    }

    public boolean isAddingContact() {
        return this.isAddingContact;
    }

    public ItemStack getKpkStack() {
        return kpkStack;
    }

    public String getCurrentContactInput() {
        return currentContactInput;
    }

    public boolean isContactInputActive() {
        return contactInputActive;
    }

    public String getCurrentChatInput() {
        return currentChatInput;
    }

    public boolean isChatInputActive() {
        return chatInputActive;
    }

    public int getCursorCounter() {
        return cursorCounter;
    }

    public int getChatScrollOffset() {
        return this.chatScrollOffset;
    }

    public void setChatScrollOffset(int offset) {
        this.chatScrollOffset = offset;
    }

    private void resetChatCreationState() {
        if (kpkStack != null) {
            ItemKPK.setChatCreationMode(kpkStack, false);
            ItemKPK.setChatCreationType(kpkStack, 0);
            ItemKPK.clearSelectedContactsForGroup(kpkStack);
        }
    }

    @Override
    public void initGui() {
        super.initGui();
        if (this.mc != null && this.mc.mouseHelper != null) {
            this.mc.mouseHelper.ungrabMouseCursor();
        }
        Keyboard.enableRepeatEvents(true);

        if (kpkStack != null) {
            if (ItemKPK.getCurrentModelPage(kpkStack) != ItemKPK.PAGE_CONTACTS) {
                this.isAddingContact = false;
            }
            if (!this.isAddingContact) {
                contactInputActive = false;
                currentContactInput = "";
            }
            if (ItemKPK.getCurrentModelPage(kpkStack) != ItemKPK.PAGE_CHAT) {
                chatInputActive = false;
                currentChatInput = "";
                resetChatCreationState();
            }
        }
    }

    @Override
    public void onGuiClosed() {
        super.onGuiClosed();
        Keyboard.enableRepeatEvents(false);
        if (this.mc != null && this.mc.mouseHelper != null && this.mc.currentScreen == null) {
            this.mc.mouseHelper.grabMouseCursor();
        }
    }

    @Override
    public void updateScreen() {
        super.updateScreen();
        cursorCounter++;
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks) {
        this.drawGradientRect(0, 0, this.width, this.height, 0x01000000, 0x01000000);
    }

    @Override
    public void handleMouseInput() throws IOException {
        super.handleMouseInput();
        int dWheel = Mouse.getEventDWheel();
        if (dWheel != 0 && kpkStack != null && ItemKPK.getCurrentModelPage(kpkStack) == ItemKPK.PAGE_CHAT) {
            int mouseX = Mouse.getEventX() * this.width / this.mc.displayWidth;
            int mouseY = this.height - Mouse.getEventY() * this.height / this.mc.displayHeight - 1;

            Rectangle channelArea = ItemKPKRenderer.modelChannelListAreaRectOnScreen;
            if (channelArea != null && channelArea.contains(mouseX, mouseY)) {
                if (dWheel > 0) this.channelScrollOffset--;
                else this.channelScrollOffset++;
            } else {
                if (dWheel > 0) this.chatScrollOffset--;
                else this.chatScrollOffset++;
            }
        }
    }

    private void sendChatMessage() {
        String messageContent = currentChatInput.trim();
        if (!messageContent.isEmpty()) {
            PacketHandler.INSTANCE.sendToServer(new PacketChatMessageToServer(ItemKPK.getCurrentChatChannelId(kpkStack), messageContent));
        }
        currentChatInput = "";
        chatInputActive = true;
    }

    private boolean checkRect(Rectangle rect, int mouseX, int mouseY) {
        return rect != null && rect.contains(mouseX, mouseY);
    }

    @Override
    protected void mouseClicked(int mouseX, int mouseY, int mouseButton) throws IOException {
        if (this.kpkStack == null || !(this.kpkStack.getItem() instanceof ItemKPK) || !ItemKPK.isEnabled(this.kpkStack)) {
            if (this.mc != null) this.mc.displayGuiScreen(null);
            return;
        }

        if (mouseButton == 1) { // ПКМ для возврата/закрытия
            if (this.isAddingContact) {
                this.isAddingContact = false;
                contactInputActive = false;
                currentContactInput = "";
            } else if (ItemKPK.isChatCreationMode(kpkStack)) {
                resetChatCreationState();
            } else {
                mc.displayGuiScreen(null);
            }
            return;
        }

        if (mouseButton != 0) return;

        contactInputActive = false;
        chatInputActive = false;

        if (checkRect(ItemKPKRenderer.modelInfoButtonRectOnScreen, mouseX, mouseY)) {
            ItemKPK.setCurrentModelPage(kpkStack, ItemKPK.PAGE_INFO);
            resetChatCreationState();
            this.isAddingContact = false;
            return;
        }
        if (checkRect(ItemKPKRenderer.modelChatButtonRectOnScreen, mouseX, mouseY)) {
            ItemKPK.setCurrentModelPage(kpkStack, ItemKPK.PAGE_CHAT);
            this.isAddingContact = false;
            return;
        }
        if (checkRect(ItemKPKRenderer.modelContactsButtonRectOnScreen, mouseX, mouseY)) {
            ItemKPK.setCurrentModelPage(kpkStack, ItemKPK.PAGE_CONTACTS);
            resetChatCreationState();
            return;
        }

        int currentPage = ItemKPK.getCurrentModelPage(kpkStack);

        if (currentPage == ItemKPK.PAGE_CHAT) {
            handleChatPageClick(mouseX, mouseY);
        } else if (currentPage == ItemKPK.PAGE_CONTACTS) {
            handleContactsPageClick(mouseX, mouseY);
        }
    }

    private void handleChatPageClick(int mouseX, int mouseY) {
        if (ItemKPK.isChatCreationMode(kpkStack)) {
            if (checkRect(ItemKPKRenderer.modelChatCreatePmButtonRectOnScreen, mouseX, mouseY)) {
                ItemKPK.setChatCreationType(kpkStack, ItemKPK.CHAT_TYPE_PM);
                ItemKPK.setCurrentModelPage(kpkStack, ItemKPK.PAGE_CONTACTS);
                return;
            }
            if (checkRect(ItemKPKRenderer.modelChatCreateGroupButtonRectOnScreen, mouseX, mouseY)) {
                ItemKPK.setChatCreationType(kpkStack, ItemKPK.CHAT_TYPE_GROUP);
                ItemKPK.setCurrentModelPage(kpkStack, ItemKPK.PAGE_CONTACTS);
                return;
            }
        } else {
            if (checkRect(ItemKPKRenderer.modelChatInputFieldRectOnScreen, mouseX, mouseY)) {
                chatInputActive = true;
                return;
            }
            if (checkRect(ItemKPKRenderer.modelChatSendButtonRectOnScreen, mouseX, mouseY)) {
                sendChatMessage();
                return;
            }
            if (checkRect(ItemKPKRenderer.modelChatCreateButtonRectOnScreen, mouseX, mouseY)) {
                ItemKPK.setChatCreationMode(kpkStack, true);
                return;
            }

            for (int i = 0; i < ItemKPKRenderer.modelChannelListButtonRectsOnScreen.size(); i++) {
                if (checkRect(ItemKPKRenderer.modelChannelListButtonRectsOnScreen.get(i), mouseX, mouseY)) {
                    String channelId = ItemKPKRenderer.modelChannelListButtonAssociatedId.get(i);
                    ItemKPK.setCurrentChatChannelId(kpkStack, channelId);
                    this.chatScrollOffset = 0;
                    return;
                }
            }

            for (int i = 0; i < ItemKPKRenderer.modelChannelDeleteButtonRectsOnScreen.size(); i++) {
                if (checkRect(ItemKPKRenderer.modelChannelDeleteButtonRectsOnScreen.get(i), mouseX, mouseY)) {
                    String channelId = ItemKPKRenderer.modelChannelDeleteButtonAssociatedId.get(i);
                    PacketHandler.INSTANCE.sendToServer(new PacketRequestDeleteChannel(channelId));
                    return;
                }
            }

            for (int i = 0; i < ItemKPKRenderer.modelMemberRemoveButtonRectsOnScreen.size(); i++) {
                if (checkRect(ItemKPKRenderer.modelMemberRemoveButtonRectsOnScreen.get(i), mouseX, mouseY)) {
                    UUID memberId = ItemKPKRenderer.modelMemberRemoveButtonAssociatedId.get(i);
                    String channelId = ItemKPK.getCurrentChatChannelId(kpkStack);
                    PacketHandler.INSTANCE.sendToServer(new PacketRequestRemoveMember(channelId, memberId));
                    return;
                }
            }
        }
    }

    private void handleContactsPageClick(int mouseX, int mouseY) {
        if (ItemKPK.isChatCreationMode(kpkStack)) {
            int creationType = ItemKPK.getChatCreationType(kpkStack);

            for (int i = 0; i < ItemKPKRenderer.modelContactDeleteButtonRectsOnScreen.size(); i++) {
                if (checkRect(ItemKPKRenderer.modelContactDeleteButtonRectsOnScreen.get(i), mouseX, mouseY)) {
                    String contactCallsign = ItemKPKRenderer.modelContactDeleteButtonAssociatedName.get(i);

                    if (creationType == ItemKPK.CHAT_TYPE_PM) {
                        PacketHandler.INSTANCE.sendToServer(new PacketRequestCreatePMChannel(contactCallsign));
                        resetChatCreationState();
                        ItemKPK.setCurrentModelPage(kpkStack, ItemKPK.PAGE_CHAT);
                        return;
                    } else if (creationType == ItemKPK.CHAT_TYPE_GROUP) {
                        List<String> selected = ItemKPK.getSelectedContactsForGroup(kpkStack);
                        if (selected.contains(contactCallsign)) {
                            ItemKPK.removeContactFromSelection(kpkStack, contactCallsign);
                        } else if (selected.size() < 2) {
                            ItemKPK.addContactToSelection(kpkStack, contactCallsign);
                        }
                        return;
                    }
                }
            }

            if (creationType == ItemKPK.CHAT_TYPE_GROUP && checkRect(ItemKPKRenderer.modelContactsConfirmAddRectOnScreen, mouseX, mouseY)) {
                List<String> selectedContacts = ItemKPK.getSelectedContactsForGroup(kpkStack);
                if (!selectedContacts.isEmpty()) {
                    mc.displayGuiScreen(new GuiTextInput(this, "Введите название канала (2-20 симв.)", (channelName) -> {
                        if (channelName != null && !channelName.isEmpty()) {
                            PacketHandler.INSTANCE.sendToServer(new PacketRequestCreateGroupChannel(channelName, selectedContacts));
                            mc.addScheduledTask(() -> {
                                resetChatCreationState();
                                ItemKPK.setCurrentModelPage(kpkStack, ItemKPK.PAGE_CHAT);
                            });
                        }
                        mc.displayGuiScreen(this);
                    }));
                }
                return;
            }

        } else {
            if (this.isAddingContact) {
                if (checkRect(ItemKPKRenderer.modelContactsInputFieldRectOnScreen, mouseX, mouseY)) {
                    contactInputActive = true;
                    return;
                }
                if (checkRect(ItemKPKRenderer.modelContactsConfirmAddRectOnScreen, mouseX, mouseY)) {
                    if (!currentContactInput.trim().isEmpty()) {
                        PacketHandler.INSTANCE.sendToServer(new PacketAddContactRequest(currentContactInput.trim()));
                    }
                    currentContactInput = "";
                    contactInputActive = true;
                    return;
                }
            } else {
                if (checkRect(ItemKPKRenderer.modelContactsAddButtonRectOnScreen, mouseX, mouseY)) {
                    this.isAddingContact = true;
                    contactInputActive = true;
                    return;
                }
                for (int i = 0; i < ItemKPKRenderer.modelContactDeleteButtonRectsOnScreen.size(); i++) {
                    if (checkRect(ItemKPKRenderer.modelContactDeleteButtonRectsOnScreen.get(i), mouseX, mouseY)) {
                        String contactNameToDelete = ItemKPKRenderer.modelContactDeleteButtonAssociatedName.get(i);
                        PacketHandler.INSTANCE.sendToServer(new PacketRemoveContactRequest(contactNameToDelete));
                        return;
                    }
                }
            }
        }
    }


    @Override
    protected void keyTyped(char typedChar, int keyCode) throws IOException {
        if (kpkStack == null) {
            super.keyTyped(typedChar, keyCode);
            return;
        }

        if (chatInputActive) {
            if (keyCode == Keyboard.KEY_ESCAPE) {
                chatInputActive = false;
                return;
            }
            if (keyCode == Keyboard.KEY_RETURN) {
                sendChatMessage();
                return;
            }
            if (isValidChar(typedChar, keyCode)) {
                currentChatInput = typeIn(currentChatInput, typedChar, keyCode, 256);
            }
            return;
        }

        if (contactInputActive) {
            if (keyCode == Keyboard.KEY_ESCAPE) {
                this.isAddingContact = false;
                contactInputActive = false;
                currentContactInput = "";
                return;
            }
            if (keyCode == Keyboard.KEY_RETURN) {
                if (!currentContactInput.trim().isEmpty()) {
                    PacketHandler.INSTANCE.sendToServer(new PacketAddContactRequest(currentContactInput.trim()));
                }
                currentContactInput = "";
                return;
            }
            if (isValidChar(typedChar, keyCode)) {
                currentContactInput = typeIn(currentContactInput, typedChar, keyCode, 32);
            }
            return;
        }

        if (keyCode == Keyboard.KEY_ESCAPE || keyCode == this.mc.gameSettings.keyBindInventory.getKeyCode()) {
            if (ItemKPK.isChatCreationMode(kpkStack)) {
                resetChatCreationState();
            } else if (this.isAddingContact) {
                this.isAddingContact = false;
                currentContactInput = "";
            } else {
                mc.displayGuiScreen(null);
            }
            return;
        }

        super.keyTyped(typedChar, keyCode);
    }

    private boolean isValidChar(char typedChar, int keyCode) {
        return net.minecraft.util.ChatAllowedCharacters.isAllowedCharacter(typedChar) || keyCode == Keyboard.KEY_BACK;
    }

    private String typeIn(String original, char typedChar, int keyCode, int maxLength) {
        if (keyCode == Keyboard.KEY_BACK) {
            if (!original.isEmpty()) {
                return original.substring(0, original.length() - 1);
            }
        } else {
            if (net.minecraft.util.ChatAllowedCharacters.isAllowedCharacter(typedChar) && original.length() < maxLength) {
                return original + typedChar;
            }
        }
        return original;
    }

    @Override
    public boolean doesGuiPauseGame() {
        return false;
    }
}===== com/example/examplemod/item/ItemKPK.java =====
package com.example.examplemod.item;

import com.example.examplemod.ExampleMod;
import com.example.examplemod.Gender;
import com.example.examplemod.User;
import com.example.examplemod.gui.GuiHandler;
import com.example.examplemod.gui.KPKModelInteractionGui;
import net.minecraft.client.util.ITooltipFlag;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.nbt.NBTTagString;
import net.minecraft.util.*;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextFormatting;
import net.minecraft.world.World;
import net.minecraftforge.common.util.Constants;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.annotation.Nullable;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

public class ItemKPK extends Item {
    public static final String TAG_ENABLED = "KpkEnabled";
    public static final String TAG_MODEL_DISPLAY_PAGE = "KpkModelDisplayPage";
    public static final String TAG_CHAT_CREATION_MODE = "KpkChatCreationMode";
    public static final String TAG_CHAT_CREATION_TYPE = "KpkChatCreationType";
    public static final String TAG_CHAT_SELECTED_CONTACTS = "KpkChatSelectedContacts";
    public static final String TAG_CURRENT_CHAT_CHANNEL_ID = "KpkCurrentChatId";

    public static final String TAG_USER_DATA = "KpkUserData";
    public static final String TAG_USER_FAMILIYA = "familiya";
    public static final String TAG_USER_NAME = "name";
    public static final String TAG_USER_POZIVNOY = "pozivnoy";
    public static final String TAG_USER_GENDER = "gender";
    public static final String TAG_USER_BIRTHDATE = "birthdate";
    public static final String TAG_CONTACTS = "KpkContacts";

    public static final int PAGE_INFO = 0;
    public static final int PAGE_CHAT = 1;
    public static final int PAGE_CONTACTS = 2;
    public static final int TOTAL_MODEL_PAGES = 3;

    public static final int SUBPAGE_CHAT_COMMON = 0;
    public static final int SUBPAGE_CHAT_CREATE = 1;

    public static final int CHAT_TYPE_PM = 1;
    public static final int CHAT_TYPE_GROUP = 2;

    private static long lastToggleTime = 0;
    private static final long TOGGLE_COOLDOWN_MS = 500;
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy");

    public ItemKPK() {
        setRegistryName(ExampleMod.MODID, "kpk_device");
        setUnlocalizedName(ExampleMod.MODID + ".kpk_device");
        setCreativeTab(net.minecraft.creativetab.CreativeTabs.TOOLS);
        setMaxStackSize(1);
    }

    private static NBTTagCompound getTag(ItemStack stack) {
        if (!stack.hasTagCompound()) {
            stack.setTagCompound(new NBTTagCompound());
        }
        return stack.getTagCompound();
    }

    public static void setUserData(ItemStack stack, User user) {
        NBTTagCompound rootTag = getTag(stack);
        if (user == null) {
            rootTag.removeTag(TAG_USER_DATA);
            return;
        }
        NBTTagCompound userTag = new NBTTagCompound();
        userTag.setString(TAG_USER_FAMILIYA, user.familiya);
        userTag.setString(TAG_USER_NAME, user.name);
        userTag.setString(TAG_USER_POZIVNOY, user.pozivnoy);
        userTag.setString(TAG_USER_GENDER, user.gender.name());
        userTag.setString(TAG_USER_BIRTHDATE, user.birthdate.format(DATE_FORMATTER));
        rootTag.setTag(TAG_USER_DATA, userTag);
    }

    @Nullable
    public static User getUserData(ItemStack stack) {
        NBTTagCompound rootTag = getTag(stack);
        if (!rootTag.hasKey(TAG_USER_DATA, Constants.NBT.TAG_COMPOUND)) {
            return null;
        }
        try {
            NBTTagCompound userTag = rootTag.getCompoundTag(TAG_USER_DATA);
            String familiya = userTag.getString(TAG_USER_FAMILIYA);
            String name = userTag.getString(TAG_USER_NAME);
            String pozivnoy = userTag.getString(TAG_USER_POZIVNOY);
            Gender gender = Gender.valueOf(userTag.getString(TAG_USER_GENDER));
            LocalDate birthdate = LocalDate.parse(userTag.getString(TAG_USER_BIRTHDATE), DATE_FORMATTER);
            return new User(familiya, name, pozivnoy, gender, birthdate);
        } catch (Exception e) {
            System.err.println("Failed to read User data from KPK ItemStack NBT");
            return null;
        }
    }

    public static List<String> getContacts(ItemStack stack) {
        List<String> contacts = new ArrayList<>();
        NBTTagList tagList = getTag(stack).getTagList(TAG_CONTACTS, Constants.NBT.TAG_STRING);
        for (int i = 0; i < tagList.tagCount(); i++) {
            contacts.add(tagList.getStringTagAt(i));
        }
        return contacts;
    }

    public static void setContacts(ItemStack stack, List<String> contacts) {
        NBTTagList tagList = new NBTTagList();
        for (String contact : contacts) {
            tagList.appendTag(new NBTTagString(contact));
        }
        getTag(stack).setTag(TAG_CONTACTS, tagList);
    }

    public static void addContact(ItemStack stack, String callsign) {
        List<String> contacts = getContacts(stack);
        if (callsign != null && !callsign.isEmpty() && !contacts.contains(callsign)) {
            contacts.add(callsign);
            setContacts(stack, contacts);
        }
    }

    public static void removeContact(ItemStack stack, String callsign) {
        List<String> contacts = getContacts(stack);
        if (contacts.remove(callsign)) {
            setContacts(stack, contacts);
        }
    }

    public static boolean isEnabled(ItemStack stack) {
        return getTag(stack).getBoolean(TAG_ENABLED);
    }

    public static void setEnabled(ItemStack stack, boolean value) {
        getTag(stack).setBoolean(TAG_ENABLED, value);
        if (!value) {
            setChatCreationMode(stack, false);
        }
    }

    public static int getCurrentModelPage(ItemStack stack) {
        NBTTagCompound tag = getTag(stack);
        if (tag.hasKey(TAG_MODEL_DISPLAY_PAGE)) {
            int page = tag.getInteger(TAG_MODEL_DISPLAY_PAGE);
            return (page >= 0 && page < TOTAL_MODEL_PAGES) ? page : PAGE_INFO;
        }
        return PAGE_INFO;
    }

    public static void setCurrentModelPage(ItemStack stack, int page) {
        getTag(stack).setInteger(TAG_MODEL_DISPLAY_PAGE, (page >= 0 && page < TOTAL_MODEL_PAGES) ? page : PAGE_INFO);
        if (page != PAGE_CHAT && page != PAGE_CONTACTS) {
            setChatCreationMode(stack, false);
        }
    }

    public static boolean isChatCreationMode(ItemStack stack) {
        return getTag(stack).getBoolean(TAG_CHAT_CREATION_MODE);
    }

    public static void setChatCreationMode(ItemStack stack, boolean mode) {
        NBTTagCompound tag = getTag(stack);
        tag.setBoolean(TAG_CHAT_CREATION_MODE, mode);
        if (!mode) {
            tag.removeTag(TAG_CHAT_CREATION_TYPE);
            tag.removeTag(TAG_CHAT_SELECTED_CONTACTS);
        }
    }

    public static int getChatCreationType(ItemStack stack) {
        return getTag(stack).getInteger(TAG_CHAT_CREATION_TYPE);
    }

    public static void setChatCreationType(ItemStack stack, int type) {
        getTag(stack).setInteger(TAG_CHAT_CREATION_TYPE, type);
    }

    public static List<String> getSelectedContactsForGroup(ItemStack stack) {
        List<String> list = new ArrayList<>();
        NBTTagList nbtList = getTag(stack).getTagList(TAG_CHAT_SELECTED_CONTACTS, Constants.NBT.TAG_STRING);
        for (int i = 0; i < nbtList.tagCount(); i++) {
            list.add(nbtList.getStringTagAt(i));
        }
        return list;
    }

    public static void addContactToSelection(ItemStack stack, String callsign) {
        NBTTagCompound tag = getTag(stack);
        NBTTagList nbtList = tag.getTagList(TAG_CHAT_SELECTED_CONTACTS, Constants.NBT.TAG_STRING);
        for (int i = 0; i < nbtList.tagCount(); i++) {
            if (nbtList.getStringTagAt(i).equals(callsign)) {
                return;
            }
        }
        nbtList.appendTag(new NBTTagString(callsign));
        tag.setTag(TAG_CHAT_SELECTED_CONTACTS, nbtList);
    }

    public static void removeContactFromSelection(ItemStack stack, String callsign) {
        NBTTagCompound tag = getTag(stack);
        NBTTagList nbtList = tag.getTagList(TAG_CHAT_SELECTED_CONTACTS, Constants.NBT.TAG_STRING);
        NBTTagList newList = new NBTTagList();
        for (int i = 0; i < nbtList.tagCount(); i++) {
            if (!nbtList.getStringTagAt(i).equals(callsign)) {
                newList.appendTag(new NBTTagString(nbtList.getStringTagAt(i)));
            }
        }
        tag.setTag(TAG_CHAT_SELECTED_CONTACTS, newList);
    }

    public static void clearSelectedContactsForGroup(ItemStack stack) {
        getTag(stack).removeTag(TAG_CHAT_SELECTED_CONTACTS);
    }

    public static String getCurrentChatChannelId(ItemStack stack) {
        NBTTagCompound tag = getTag(stack);
        if (tag.hasKey(TAG_CURRENT_CHAT_CHANNEL_ID)) {
            return tag.getString(TAG_CURRENT_CHAT_CHANNEL_ID);
        }
        return com.example.examplemod.chat.ChatChannel.COMMON_CHANNEL_ID_PREFIX;
    }

    public static void setCurrentChatChannelId(ItemStack stack, String channelId) {
        if (channelId != null) {
            getTag(stack).setString(TAG_CURRENT_CHAT_CHANNEL_ID, channelId);
        }
    }

    @Override
    public ActionResult<ItemStack> onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn) {
        ItemStack stack = playerIn.getHeldItem(handIn);

        if (playerIn.isSneaking()) {
            long currentTime = System.currentTimeMillis();
            if (worldIn.isRemote && currentTime - lastToggleTime < TOGGLE_COOLDOWN_MS) {
                return new ActionResult<>(EnumActionResult.PASS, stack);
            }
            if (worldIn.isRemote) lastToggleTime = currentTime;

            boolean currentState = isEnabled(stack);
            setEnabled(stack, !currentState);

            if (!worldIn.isRemote) {
                TextComponentString message;
                if (!currentState) {
                    message = new TextComponentString(TextFormatting.GREEN + "КПК включён");
                    if (getUserData(stack) != null) {
                        setCurrentModelPage(stack, PAGE_INFO);
                    }
                } else {
                    message = new TextComponentString(TextFormatting.RED + "КПК выключен");
                }
                playerIn.sendMessage(message);
            }

            if (currentState && worldIn.isRemote) {
                playerIn.closeScreen();
            }

            return new ActionResult<>(EnumActionResult.SUCCESS, stack);

        } else {
            if (isEnabled(stack)) {
                if (getUserData(stack) == null) {
                    if (!worldIn.isRemote) {
                        TextComponentString notSetupMessage = new TextComponentString(TextFormatting.RED + "КПК не настроен. Используйте команду /kpk set, держа его в руке.");
                        playerIn.sendMessage(notSetupMessage);
                    }
                    return new ActionResult<>(EnumActionResult.FAIL, stack);
                }

                if (worldIn.isRemote) {
                    if (net.minecraft.client.Minecraft.getMinecraft().currentScreen instanceof KPKModelInteractionGui) {
                        playerIn.closeScreen();
                    } else {
                        playerIn.openGui(ExampleMod.instance, GuiHandler.KPK_MODEL_INTERACTION_GUI_ID, worldIn, (int)playerIn.posX, (int)playerIn.posY, (int)playerIn.posZ);
                    }
                }
            } else {
                if (!worldIn.isRemote) {
                    TextComponentString disabledMessage = new TextComponentString(TextFormatting.YELLOW + "КПК выключен. Включите с помощью Shift + ПКМ.");
                    playerIn.sendMessage(disabledMessage);
                }
            }
            return new ActionResult<>(EnumActionResult.SUCCESS, stack);
        }
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void addInformation(ItemStack stack, @Nullable World worldIn, List<String> tooltip, ITooltipFlag flagIn) {
        tooltip.add(TextFormatting.GRAY + "Персональное КПК устройство");

        User user = getUserData(stack);
        if (user != null) {
            tooltip.add(TextFormatting.AQUA + "Позывной: " + TextFormatting.WHITE + user.pozivnoy);
        } else {
            tooltip.add(TextFormatting.RED + "Не настроен");
        }

        tooltip.add(TextFormatting.YELLOW + (isEnabled(stack) ? "Включено" : "Выключено"));
        tooltip.add(TextFormatting.DARK_GRAY + "Shift+ПКМ - вкл/выкл");
        if (isEnabled(stack)) {
            tooltip.add(TextFormatting.DARK_GRAY + "ПКМ - режим курсора");
        }
    }

    @Override
    public boolean hasEffect(ItemStack stack) {
        return false;
    }
}===== com/example/examplemod/item/ItemKPKRenderer.java =====
package com.example.examplemod.item;

import com.example.examplemod.ExampleMod;
import com.example.examplemod.User;
import com.example.examplemod.chat.ChatChannel;
import com.example.examplemod.chat.ChatChannelType;
import com.example.examplemod.chat.ChatMessage;
import com.example.examplemod.chat.ClientChatCache;
import com.example.examplemod.gui.KPKModelInteractionGui;
import com.google.common.collect.ImmutableMap;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.AbstractClientPlayer;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.ScaledResolution;
import net.minecraft.client.renderer.*;
import net.minecraft.client.renderer.block.model.BakedQuad;
import net.minecraft.client.renderer.block.model.IBakedModel;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.client.renderer.tileentity.TileEntityItemStackRenderer;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.client.renderer.vertex.VertexBuffer;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHandSide;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.text.TextFormatting;
import net.minecraftforge.client.model.IModel;
import net.minecraftforge.client.model.ModelLoaderRegistry;
import net.minecraftforge.client.model.obj.OBJModel;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.commons.lang3.tuple.Pair;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.GL11;
import org.lwjgl.util.glu.GLU;

import java.awt.*;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@SideOnly(Side.CLIENT)
public class ItemKPKRenderer extends TileEntityItemStackRenderer {
    private static ItemCameraTransforms.TransformType currentTransform = ItemCameraTransforms.TransformType.NONE;
    private IBakedModel tabletModel;
    private boolean modelLoaded = false;
    private static final float MODEL_SCALE = 0.4f;
    private static Minecraft mc = Minecraft.getMinecraft();
    private int previousFormattedLinesCount = 0;
    private int channelScrollOffset = 0;

    private static final FloatBuffer modelView = BufferUtils.createFloatBuffer(16);
    private static final FloatBuffer projection = BufferUtils.createFloatBuffer(16);
    private static final IntBuffer viewport = BufferUtils.createIntBuffer(16);

    private static final Map<String, List<Pair<String, Boolean>>> FONT_CACHE = new ConcurrentHashMap<>();
    private static boolean isFontCacheDirty = true;
    private static int lastScreenWidth = 0;
    private static int lastScreenHeight = 0;

    private static VertexBuffer tabletVBO;

    static {
        ClientChatCache.addOnChatDataUpdatedListener(ItemKPKRenderer::invalidateFontCache);
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            if (tabletVBO != null) {
                tabletVBO.deleteGlBuffers();
            }
        }));
    }

    public static void invalidateFontCache() {
        isFontCacheDirty = true;
    }


    public static Rectangle modelInfoButtonRectOnScreen = null;
    public static Rectangle modelChatButtonRectOnScreen = null;
    public static Rectangle modelContactsButtonRectOnScreen = null;
    public static Rectangle modelChatCreateButtonRectOnScreen = null;
    public static Rectangle modelChatInputFieldRectOnScreen = null;
    public static Rectangle modelChatSendButtonRectOnScreen = null;
    public static Rectangle modelContactsAddButtonRectOnScreen = null;
    public static Rectangle modelContactsInputFieldRectOnScreen = null;
    public static Rectangle modelContactsConfirmAddRectOnScreen = null;
    public static Rectangle modelChatCreatePmButtonRectOnScreen = null;
    public static Rectangle modelChatCreateGroupButtonRectOnScreen = null;
    public static List<Rectangle> modelChannelListButtonRectsOnScreen = new ArrayList<>();
    public static List<String> modelChannelListButtonAssociatedId = new ArrayList<>();
    public static Rectangle modelChannelListAreaRectOnScreen = null;
    public static List<Rectangle> modelContactDeleteButtonRectsOnScreen = new ArrayList<>();
    public static List<String> modelContactDeleteButtonAssociatedName = new ArrayList<>();
    public static List<Rectangle> modelChannelDeleteButtonRectsOnScreen = new ArrayList<>();
    public static List<String> modelChannelDeleteButtonAssociatedId = new ArrayList<>();
    public static List<Rectangle> modelMemberRemoveButtonRectsOnScreen = new ArrayList<>();
    public static List<UUID> modelMemberRemoveButtonAssociatedId = new ArrayList<>();

    private static final int COLOR_BORDER = 0xFF1E1E1E;
    private static final int COLOR_INACTIVE_TOP = 0xFF4F4F4F;
    private static final int COLOR_INACTIVE_BOTTOM = 0xFF3A3A3A;
    private static final int COLOR_ACTIVE_TOP = 0xFF6A6A6A;
    private static final int COLOR_ACTIVE_BOTTOM = 0xFF555555;
    private static final int COLOR_POSITIVE_TOP = 0xFF00B200;
    private static final int COLOR_POSITIVE_BOTTOM = 0xFF008C00;
    private static final int COLOR_NEGATIVE_TOP = 0xFFD40000;
    private static final int COLOR_NEGATIVE_BOTTOM = 0xFFA00000;

    private static final int COLOR_INPUT_BG = 0xFF2B2B2B;
    private static final int COLOR_INPUT_SHADOW_DARK = 0xFF212121;
    private static final int COLOR_INPUT_SHADOW_LIGHT = 0xFF454545;
    private static final int COLOR_INPUT_BORDER_ACTIVE = 0xFF55AFFF;

    public ItemKPKRenderer() {
        super();
    }

    private void drawStyledInputField(int x, int y, int width, int height, boolean isActive) {
        if (isActive) {
            Gui.drawRect(x - 1, y - 1, x + width + 1, y, COLOR_INPUT_BORDER_ACTIVE); // Top
            Gui.drawRect(x - 1, y + height, x + width + 1, y + height + 1, COLOR_INPUT_BORDER_ACTIVE); // Bottom
            Gui.drawRect(x - 1, y, x, y + height, COLOR_INPUT_BORDER_ACTIVE); // Left
            Gui.drawRect(x + width, y, x + width + 1, y + height, COLOR_INPUT_BORDER_ACTIVE); // Right
        }

        Gui.drawRect(x, y, x + width, y + height, COLOR_INPUT_BG);

        Gui.drawRect(x, y, x + width, y + 1, COLOR_INPUT_SHADOW_DARK);
        Gui.drawRect(x, y + 1, x + 1, y + height, COLOR_INPUT_SHADOW_DARK);
        Gui.drawRect(x + 1, y + height - 1, x + width, y + height, COLOR_INPUT_SHADOW_LIGHT);
        Gui.drawRect(x + width - 1, y + 1, x + width, y + height - 1, COLOR_INPUT_SHADOW_LIGHT);
    }

    private void drawStyledButton(int x, int y, int width, int height, int topColor, int bottomColor, int borderColor) {
        Gui.drawRect(x, y, x + width, y + height, borderColor);
        this.drawGradientRect(x + 1, y + 1, x + width - 1, y + height - 1, topColor, bottomColor);
    }

    protected void drawGradientRect(int left, int top, int right, int bottom, int startColor, int endColor) {
        float startAlpha = (float)(startColor >> 24 & 255) / 255.0F;
        float startRed = (float)(startColor >> 16 & 255) / 255.0F;
        float startGreen = (float)(startColor >> 8 & 255) / 255.0F;
        float startBlue = (float)(startColor & 255) / 255.0F;
        float endAlpha = (float)(endColor >> 24 & 255) / 255.0F;
        float endRed = (float)(endColor >> 16 & 255) / 255.0F;
        float endGreen = (float)(endColor >> 8 & 255) / 255.0F;
        float endBlue = (float)(endColor & 255) / 255.0F;

        GlStateManager.disableTexture2D();
        GlStateManager.enableBlend();
        GlStateManager.disableAlpha();
        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
        GlStateManager.shadeModel(GL11.GL_SMOOTH);

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder bufferbuilder = tessellator.getBuffer();
        bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
        bufferbuilder.pos((double)right, (double)top, 0.0D).color(startRed, startGreen, startBlue, startAlpha).endVertex();
        bufferbuilder.pos((double)left, (double)top, 0.0D).color(startRed, startGreen, startBlue, startAlpha).endVertex();
        bufferbuilder.pos((double)left, (double)bottom, 0.0D).color(endRed, endGreen, endBlue, endAlpha).endVertex();
        bufferbuilder.pos((double)right, (double)bottom, 0.0D).color(endRed, endGreen, endBlue, endAlpha).endVertex();
        tessellator.draw();

        GlStateManager.shadeModel(GL11.GL_FLAT);
        GlStateManager.disableBlend();
        GlStateManager.enableAlpha();
        GlStateManager.enableTexture2D();
    }

    private void loadModel() {
        if (!modelLoaded) {
            try {
                IModel model = ModelLoaderRegistry.getModel(new ResourceLocation(ExampleMod.MODID, "item/kpk.obj"));
                if (model instanceof OBJModel) {
                    OBJModel objModel = (OBJModel) model;
                    objModel = (OBJModel) objModel.retexture(ImmutableMap.of(
                            "material", ExampleMod.MODID + ":items/kpk_item",
                            "#material", ExampleMod.MODID + ":items/kpk_item"
                    ));
                    objModel = (OBJModel) objModel.process(ImmutableMap.of("flip-v", "true"));
                    model = objModel;
                }
                tabletModel = model.bake(
                        model.getDefaultState(),
                        DefaultVertexFormats.ITEM,
                        location -> Minecraft.getMinecraft().getTextureMapBlocks().getAtlasSprite(location.toString())
                );
                modelLoaded = true;
            } catch (Exception e) {
                System.err.println("Failed to load tablet model: " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    @Override
    public void renderByItem(ItemStack stack, float partialTicks) {
        loadModel();
        GlStateManager.pushMatrix();
        applyTabletTransform(currentTransform);

        if (tabletModel != null) {
            renderTabletModel();
        }

        if (currentTransform == ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND ||
                currentTransform == ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND) {
            renderHandsHoldingTablet();
            if (ItemKPK.isEnabled(stack)) {
                renderModelScreen(stack);
            }
        }
        GlStateManager.popMatrix();
    }

    private void renderHandsHoldingTablet() {
        AbstractClientPlayer player = mc.player;
        if (player == null) return;
        GlStateManager.pushMatrix();
        renderArm(EnumHandSide.RIGHT, player);
        renderArm(EnumHandSide.LEFT, player);
        GlStateManager.popMatrix();
    }

    private void renderArm(EnumHandSide side, AbstractClientPlayer player) {
        GlStateManager.pushMatrix();
        if (side == EnumHandSide.RIGHT) {
            GlStateManager.translate(7.6F, -7F, -13F);
            GlStateManager.rotate(-10.0F, 0.0F, 1.0F, 0.0F);
            GlStateManager.rotate(8.0F, 1.0F, 0.0F, 0.0F);
            GlStateManager.rotate(-15.0F, 0.0F, 0.0F, 1.0F);
        } else {
            GlStateManager.translate(1.5F, -5.6F, 3.7F);
            GlStateManager.rotate(20.0F, 0.0F, 1.0F, 0.0F);
            GlStateManager.rotate(-12.0F, 1.0F, 0.0F, 0.0F);
            GlStateManager.rotate(-2.0F, 0.0F, 0.0F, 1.0F);
        }
        GlStateManager.scale(10.2F, 10.2F, 10.2F);
        mc.getTextureManager().bindTexture(player.getLocationSkin());
        GlStateManager.enableLighting();
        GlStateManager.disableCull();
        if (side == EnumHandSide.RIGHT) {
            mc.getRenderManager().getSkinMap().get("default").renderRightArm(player);
        } else {
            mc.getRenderManager().getSkinMap().get("default").renderLeftArm(player);
        }
        GlStateManager.enableCull();
        GlStateManager.popMatrix();
    }

    private void generateTabletVBO() {
        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder bufferbuilder = tessellator.getBuffer();
        bufferbuilder.begin(7, DefaultVertexFormats.ITEM);
        for (EnumFacing enumfacing : EnumFacing.values()) {
            renderQuads(bufferbuilder, tabletModel.getQuads(null, enumfacing, 0L), -1);
        }
        renderQuads(bufferbuilder, tabletModel.getQuads(null, null, 0L), -1);

        bufferbuilder.finishDrawing();
        tabletVBO = new VertexBuffer(DefaultVertexFormats.ITEM);
        tabletVBO.bufferData(bufferbuilder.getByteBuffer().asReadOnlyBuffer());
    }


    private void renderTabletModel() {
        if (tabletModel == null) return;

        mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
        mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
        GlStateManager.enableRescaleNormal();
        GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);
        GlStateManager.enableBlend();
        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
        RenderHelper.enableStandardItemLighting();

        GlStateManager.pushMatrix();
        GlStateManager.translate(1F, 2F, -6);

        if (tabletVBO == null) {
            generateTabletVBO();
        }

        tabletVBO.bindBuffer();

        int stride = DefaultVertexFormats.ITEM.getIntegerSize() * 4;
        GlStateManager.glVertexPointer(3, GL11.GL_FLOAT, stride, 0);
        GlStateManager.glColorPointer(4, GL11.GL_UNSIGNED_BYTE, stride, 12);
        GlStateManager.glTexCoordPointer(2, GL11.GL_FLOAT, stride, 16);
        GL11.glNormalPointer(GL11.GL_BYTE, stride, 24);

        GlStateManager.glEnableClientState(GL11.GL_VERTEX_ARRAY);
        GlStateManager.glEnableClientState(GL11.GL_COLOR_ARRAY);
        GlStateManager.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
        GlStateManager.glEnableClientState(GL11.GL_NORMAL_ARRAY);

        tabletVBO.drawArrays(GL11.GL_QUADS);

        tabletVBO.unbindBuffer();
        GlStateManager.glDisableClientState(GL11.GL_NORMAL_ARRAY);
        GlStateManager.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
        GlStateManager.glDisableClientState(GL11.GL_COLOR_ARRAY);
        GlStateManager.glDisableClientState(GL11.GL_VERTEX_ARRAY);

        GlStateManager.popMatrix();
        RenderHelper.disableStandardItemLighting();
        GlStateManager.disableRescaleNormal();
        GlStateManager.disableBlend();
        mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
    }

    private void renderQuads(BufferBuilder renderer, List<BakedQuad> quads, int color) {
        for (BakedQuad bakedquad : quads) {
            net.minecraftforge.client.model.pipeline.LightUtil.renderQuadColor(renderer, bakedquad, color);
        }
    }

    private void renderModelScreen(ItemStack stack) {
        boolean interactionGuiOpen = mc.currentScreen instanceof KPKModelInteractionGui;

        GlStateManager.pushMatrix();
        GlStateManager.translate(0.5F, 2.0F, -6.005F);

        float desiredInterfaceWidthVirtual = 180f;
        float desiredInterfaceHeightVirtual = 110f;
        float modelPhysicalScreenWidth = 1.7f;
        float interfaceScale = modelPhysicalScreenWidth / desiredInterfaceWidthVirtual;
        GlStateManager.scale(interfaceScale, interfaceScale, interfaceScale);

        GlStateManager.rotate(270F, 0.0F, 1.0F, 0.0F);
        GlStateManager.rotate(180.0F, 1.0F, 0.0F, 0.0F);

        GlStateManager.translate(-desiredInterfaceWidthVirtual / 2f, -desiredInterfaceHeightVirtual / 2f, 0.01F);

        ScaledResolution sr = null;
        if (interactionGuiOpen) {
            modelView.clear();
            projection.clear();
            viewport.clear();

            GL11.glGetFloat(GL11.GL_MODELVIEW_MATRIX, modelView);
            GL11.glGetFloat(GL11.GL_PROJECTION_MATRIX, projection);
            GL11.glGetInteger(GL11.GL_VIEWPORT, viewport);
            sr = new ScaledResolution(mc);
        }

        GlStateManager.disableLighting();
        GlStateManager.enableBlend();
        GlStateManager.tryBlendFuncSeparate(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA, GL11.GL_ONE, GL11.GL_ZERO);
        GlStateManager.disableDepth();

        FontRenderer fontRenderer = mc.fontRenderer;

        int topButtonWidth = 45;
        int topButtonHeight = 14;
        int topButtonY = -68;
        int topButtonSpacing = 3;
        int totalTopButtonsWidth = (topButtonWidth * ItemKPK.TOTAL_MODEL_PAGES) + (topButtonSpacing * (ItemKPK.TOTAL_MODEL_PAGES -1));
        int topTabStartX = (int)((desiredInterfaceWidthVirtual - totalTopButtonsWidth) / 2f - 176);
        int currentTopButtonX = topTabStartX;

        int currentPage = ItemKPK.getCurrentModelPage(stack);

        boolean isInfoActive = (currentPage == ItemKPK.PAGE_INFO);
        drawStyledButton(currentTopButtonX, topButtonY, topButtonWidth, topButtonHeight,
                isInfoActive ? COLOR_ACTIVE_TOP : COLOR_INACTIVE_TOP,
                isInfoActive ? COLOR_ACTIVE_BOTTOM : COLOR_INACTIVE_BOTTOM,
                COLOR_BORDER);
        drawCenteredStringWithShadow(fontRenderer, TextFormatting.BOLD + "ИНФА", currentTopButtonX + topButtonWidth/2, topButtonY + (topButtonHeight - fontRenderer.FONT_HEIGHT)/2 + 1, isInfoActive ? 0xFFFFFFFF : 0xFFAAAAAA);
        if(interactionGuiOpen) ItemKPKRenderer.modelInfoButtonRectOnScreen = calculateScreenRectForVirtual(currentTopButtonX, topButtonY, topButtonWidth, topButtonHeight, modelView, projection, viewport, sr);

        currentTopButtonX += topButtonWidth + topButtonSpacing;

        boolean isChatActive = (currentPage == ItemKPK.PAGE_CHAT);
        drawStyledButton(currentTopButtonX, topButtonY, topButtonWidth, topButtonHeight,
                isChatActive ? COLOR_ACTIVE_TOP : COLOR_INACTIVE_TOP,
                isChatActive ? COLOR_ACTIVE_BOTTOM : COLOR_INACTIVE_BOTTOM,
                COLOR_BORDER);
        drawCenteredStringWithShadow(fontRenderer, TextFormatting.BOLD + "ЧАТ", currentTopButtonX + topButtonWidth/2, topButtonY + (topButtonHeight - fontRenderer.FONT_HEIGHT) / 2 + 1, isChatActive ? 0xFFFFFFFF : 0xFFAAAAAA);
        if(interactionGuiOpen) ItemKPKRenderer.modelChatButtonRectOnScreen = calculateScreenRectForVirtual(currentTopButtonX, topButtonY, topButtonWidth, topButtonHeight, modelView, projection, viewport, sr);

        currentTopButtonX += topButtonWidth + topButtonSpacing;

        boolean isContactsActive = (currentPage == ItemKPK.PAGE_CONTACTS);
        drawStyledButton(currentTopButtonX, topButtonY, topButtonWidth, topButtonHeight,
                isContactsActive ? COLOR_ACTIVE_TOP : COLOR_INACTIVE_TOP,
                isContactsActive ? COLOR_ACTIVE_BOTTOM : COLOR_INACTIVE_BOTTOM,
                COLOR_BORDER);
        drawCenteredStringWithShadow(fontRenderer, TextFormatting.BOLD + "КОНТАКТЫ", currentTopButtonX + topButtonWidth/2, topButtonY + (topButtonHeight - fontRenderer.FONT_HEIGHT)/2 + 1, isContactsActive ? 0xFFFFFFFF : 0xFFAAAAAA);
        if(interactionGuiOpen) ItemKPKRenderer.modelContactsButtonRectOnScreen = calculateScreenRectForVirtual(currentTopButtonX, topButtonY, topButtonWidth, topButtonHeight, modelView, projection, viewport, sr);

        if (!interactionGuiOpen) {
            modelChatCreateButtonRectOnScreen = null;
            modelContactsAddButtonRectOnScreen = null;
            modelContactsInputFieldRectOnScreen = null;
            modelContactsConfirmAddRectOnScreen = null;
            modelChatInputFieldRectOnScreen = null;
            modelChatSendButtonRectOnScreen = null;
            modelChatCreatePmButtonRectOnScreen = null;
            modelChatCreateGroupButtonRectOnScreen = null;
            modelChannelListAreaRectOnScreen = null;
            if (modelChannelListButtonRectsOnScreen != null) modelChannelListButtonRectsOnScreen.clear();
            if (modelChannelListButtonAssociatedId != null) modelChannelListButtonAssociatedId.clear();
            if (modelContactDeleteButtonRectsOnScreen != null) modelContactDeleteButtonRectsOnScreen.clear();
            if (modelContactDeleteButtonAssociatedName != null) modelContactDeleteButtonAssociatedName.clear();
            if (modelChannelDeleteButtonRectsOnScreen != null) modelChannelDeleteButtonRectsOnScreen.clear();
            if (modelChannelDeleteButtonAssociatedId != null) modelChannelDeleteButtonAssociatedId.clear();
            if (modelMemberRemoveButtonRectsOnScreen != null) modelMemberRemoveButtonRectsOnScreen.clear();
            if (modelMemberRemoveButtonAssociatedId != null) modelMemberRemoveButtonAssociatedId.clear();
        }

        User userData = ItemKPK.getUserData(stack);

        if (userData != null) {
            if (currentPage == ItemKPK.PAGE_INFO) {
                renderInfoPage(userData);
            } else if (currentPage == ItemKPK.PAGE_CHAT) {
                renderChatPage(stack, interactionGuiOpen, modelView, projection, viewport, sr);
            } else if (currentPage == ItemKPK.PAGE_CONTACTS) {
                if (ItemKPK.isChatCreationMode(stack)) {
                    renderContactSelection(stack, interactionGuiOpen, modelView, projection, viewport, sr);
                } else {
                    renderContactList(stack, interactionGuiOpen, modelView, projection, viewport, sr);
                }
            }
        } else {
            drawCenteredStringWithShadow(fontRenderer, "КПК НЕ ИНИЦИАЛИЗИРОВАН", 0, -5, 0xFF5555);
            drawCenteredStringWithShadow(fontRenderer, "Используйте /kpk set", 0, 5, 0xFFFF55);
        }

        if (currentPage != ItemKPK.PAGE_CHAT) {
            this.previousFormattedLinesCount = 0;
        }

        GlStateManager.enableDepth();
        GlStateManager.enableLighting();
        GlStateManager.disableBlend();
        GlStateManager.popMatrix();
    }

    private void renderInfoPage(User userData) {
        int contentStartX = -150;
        int lineHeight = mc.fontRenderer.FONT_HEIGHT + 2;

        if (userData == null) {
            mc.fontRenderer.drawStringWithShadow("ДАННЫЕ НЕ ЗАГРУЖЕНЫ", contentStartX + 100, 0, 0xFFCC00);
        } else {
            String title = TextFormatting.GOLD + "" + TextFormatting.BOLD + "КПК: УСТРОЙСТВО";
            GlStateManager.pushMatrix();
            float titleScaleFactor = 1.5f;
            float originalTitleX = contentStartX + 355;
            float originalTitleY = -46;

            GlStateManager.translate(originalTitleX, originalTitleY, 0);
            GlStateManager.scale(titleScaleFactor, titleScaleFactor, 1.0f);
            mc.fontRenderer.drawStringWithShadow(title, 0, 0, 0xFFD700);
            GlStateManager.popMatrix();

            float dataBlockStartY = originalTitleY + (mc.fontRenderer.FONT_HEIGHT * titleScaleFactor) + 5;
            float dataBlockStartX = contentStartX;
            String[] labels = {"Владелец:", "Позывной:", "Дата рождения:", "Пол:"};
            String[] values = {
                    TextFormatting.WHITE + userData.familiya + " " + userData.name,
                    TextFormatting.WHITE + userData.pozivnoy,
                    TextFormatting.WHITE + userData.birthdate.format(DateTimeFormatter.ofPattern("dd.MM.yyyy")),
                    TextFormatting.WHITE + userData.gender.getDisplayName()
            };
            float dataScaleFactor = 2.3f;
            for(int i = 0; i < labels.length; i++) {
                String lineToDraw = labels[i] + " " + values[i];
                GlStateManager.pushMatrix();
                float currentLineY = dataBlockStartY + (i * (int)(lineHeight * dataScaleFactor));
                GlStateManager.translate(dataBlockStartX, currentLineY , 0);
                GlStateManager.scale(dataScaleFactor, dataScaleFactor, 1.0f);
                mc.fontRenderer.drawStringWithShadow(lineToDraw, 0, 0, 0x00FFFF);
                GlStateManager.popMatrix();
            }
        }
    }

    private void renderChatPage(ItemStack stack, boolean interactionGuiOpen, FloatBuffer mv, FloatBuffer proj, IntBuffer vp, ScaledResolution sr) {
        renderChannelList(stack, interactionGuiOpen, mv, proj, vp, sr);
        renderChatHistoryAndInput(stack, interactionGuiOpen, mv, proj, vp, sr);
        renderMemberList(stack, interactionGuiOpen, mv, proj, vp, sr);

        if (interactionGuiOpen && ItemKPK.isChatCreationMode(stack)) {
            renderChatCreateOverlay(stack, interactionGuiOpen, mv, proj, vp, sr);
        }
    }

    private void renderChannelList(ItemStack stack, boolean interactionGuiOpen, FloatBuffer mv, FloatBuffer proj, IntBuffer vp, ScaledResolution sr) {
        int listX = -157;
        int listY = -45;
        int listWidth = 93;
        int listHeight = 195;
        int createBtnHeight = 20;
        int itemHeight = 22;

        Gui.drawRect(listX, listY, listX + listWidth, listY + listHeight, 0xAA000000);
        if (interactionGuiOpen) {
            modelChannelListAreaRectOnScreen = calculateScreenRectForVirtual(listX, listY, listWidth, listHeight, mv, proj, vp, sr);
        }

        if (interactionGuiOpen) {
            modelChannelListButtonRectsOnScreen.clear();
            modelChannelListButtonAssociatedId.clear();
            modelChannelDeleteButtonRectsOnScreen.clear();
            modelChannelDeleteButtonAssociatedId.clear();
        }

        List<ChatChannel> channels = ClientChatCache.getSubscribedChannels();

        int maxVisible = (listHeight - createBtnHeight - 5) / itemHeight;

        if (mc.currentScreen instanceof KPKModelInteractionGui) {
            KPKModelInteractionGui gui = (KPKModelInteractionGui) mc.currentScreen;
            if (gui.channelScrollOffset > channels.size() - maxVisible) gui.channelScrollOffset = Math.max(0, channels.size() - maxVisible);
            if (gui.channelScrollOffset < 0) gui.channelScrollOffset = 0;
            this.channelScrollOffset = gui.channelScrollOffset;
        }

        String currentChannelId = ItemKPK.getCurrentChatChannelId(stack);

        for (int i = 0; i < maxVisible; i++) {
            int channelIndex = i + channelScrollOffset;
            if (channelIndex < channels.size()) {
                ChatChannel channel = channels.get(channelIndex);
                int itemY = listY + i * itemHeight;
                boolean isActive = channel.getChannelId().equals(currentChannelId);

                drawStyledButton(listX, itemY, listWidth, itemHeight,
                        isActive ? COLOR_ACTIVE_TOP : COLOR_INACTIVE_TOP,
                        isActive ? COLOR_ACTIVE_BOTTOM : COLOR_INACTIVE_BOTTOM,
                        COLOR_BORDER);

                String displayName = mc.fontRenderer.trimStringToWidth(channel.getDisplayName(), listWidth - 16);
                drawCenteredStringWithShadow(mc.fontRenderer, displayName, listX + listWidth / 2, itemY + (itemHeight - 8) / 2, isActive ? 0xFFFFFFFF : 0xFFAAAAAA);

                if (interactionGuiOpen) {
                    modelChannelListButtonRectsOnScreen.add(calculateScreenRectForVirtual(listX, itemY, listWidth, itemHeight, mv, proj, vp, sr));
                    modelChannelListButtonAssociatedId.add(channel.getChannelId());

                    if (channel.getType() == ChatChannelType.PRIVATE_MESSAGE || channel.getType() == ChatChannelType.PRIVATE_GROUP) {
                        int delButtonSize = 10;
                        int delButtonX = listX + listWidth - delButtonSize - 2;
                        int delButtonY = itemY + (itemHeight - delButtonSize) / 2;
                        drawStyledButton(delButtonX, delButtonY, delButtonSize, delButtonSize, COLOR_NEGATIVE_TOP, COLOR_NEGATIVE_BOTTOM, COLOR_BORDER);
                        drawCenteredStringWithShadow(mc.fontRenderer, "X", delButtonX + delButtonSize / 2, delButtonY + 1, 0xFFFFFFFF);

                        modelChannelDeleteButtonRectsOnScreen.add(calculateScreenRectForVirtual(delButtonX, delButtonY, delButtonSize, delButtonSize, mv, proj, vp, sr));
                        modelChannelDeleteButtonAssociatedId.add(channel.getChannelId());
                    }
                }
            }
        }

        int createBtnY = listY + listHeight - createBtnHeight + 18;
        drawStyledButton(listX, createBtnY, listWidth, createBtnHeight, COLOR_INACTIVE_TOP, COLOR_INACTIVE_BOTTOM, COLOR_BORDER);
        drawCenteredStringWithShadow(mc.fontRenderer, TextFormatting.BOLD + "Создать", listX + listWidth/2, createBtnY + (createBtnHeight - 8) / 2 + 1, 0xFFFFFFFF);
        if (interactionGuiOpen) {
            modelChatCreateButtonRectOnScreen = calculateScreenRectForVirtual(listX, createBtnY, listWidth, createBtnHeight, mv, proj, vp, sr);
        }
    }

    private void renderChatHistoryAndInput(ItemStack stack, boolean interactionGuiOpen, FloatBuffer mv, FloatBuffer proj, IntBuffer vp, ScaledResolution sr) {
        KPKModelInteractionGui kpkGui = null;
        if (interactionGuiOpen) {
            kpkGui = (KPKModelInteractionGui) mc.currentScreen;
        }

        String currentChannelId = ItemKPK.getCurrentChatChannelId(stack);
        ChatChannel channel = ClientChatCache.getChannel(currentChannelId);

        if (mc.displayWidth != lastScreenWidth || mc.displayHeight != lastScreenHeight) {
            invalidateFontCache();
            lastScreenWidth = mc.displayWidth;
            lastScreenHeight = mc.displayHeight;
        }

        final float CHAT_TEXT_SCALE = 1.5f;
        int chatHistoryX = -54;
        int chatHistoryY = -45;
        int chatInputY = 171;

        final int MEMBER_LIST_WIDTH = 80;
        final int GAP = 6;
        final int FULL_WIDTH = 364;

        int chatHistoryWidth;
        if (channel != null && channel.getType() != ChatChannelType.COMMON_SERVER_WIDE) {
            chatHistoryWidth = FULL_WIDTH - MEMBER_LIST_WIDTH - GAP;
        } else {
            chatHistoryWidth = FULL_WIDTH;
        }

        int chatHistoryHeight = chatInputY - chatHistoryY;
        int chatLineHeight = 10;
        int maxVisibleLines = (int)(chatHistoryHeight / (chatLineHeight * CHAT_TEXT_SCALE));

        List<Pair<String, Boolean>> finalLines;

        if (isFontCacheDirty) {
            FONT_CACHE.clear();

            for (ChatChannel subscribedChannel : ClientChatCache.getSubscribedChannels()) {
                String cacheChannelId = subscribedChannel.getChannelId();
                int currentWrappingWidth;
                if (subscribedChannel.getType() != ChatChannelType.COMMON_SERVER_WIDE) {
                    currentWrappingWidth = (int)((FULL_WIDTH - MEMBER_LIST_WIDTH - GAP) / CHAT_TEXT_SCALE);
                } else {
                    currentWrappingWidth = (int)(FULL_WIDTH / CHAT_TEXT_SCALE);
                }

                List<Pair<String, Boolean>> processedLines = new ArrayList<>();
                List<ChatMessage> messages = ClientChatCache.getChatHistory(cacheChannelId);

                for (ChatMessage msg : messages) {
                    boolean isSelf = msg.senderUuid != null && mc.player != null && msg.senderUuid.equals(mc.player.getUniqueID());

                    if (isSelf) {
                        String suffix = " :" + TextFormatting.GRAY + msg.senderCallsign + " " + TextFormatting.GRAY + "[" + msg.getFormattedTimestamp() + "]";
                        int wrapWidth = currentWrappingWidth - mc.fontRenderer.getStringWidth(suffix);
                        List<String> wrappedContent = mc.fontRenderer.listFormattedStringToWidth(msg.messageContent, wrapWidth > 0 ? wrapWidth : 1);

                        for(int i = 0; i < wrappedContent.size(); i++) {
                            String line = wrappedContent.get(i);
                            processedLines.add(Pair.of(i == wrappedContent.size() - 1 ? line + suffix : line, true));
                        }
                    } else {
                        String prefix = TextFormatting.GRAY + "[" + msg.getFormattedTimestamp() + "] " + TextFormatting.GRAY + msg.senderCallsign + TextFormatting.WHITE + ": ";
                        int wrapWidth = currentWrappingWidth - mc.fontRenderer.getStringWidth(prefix);
                        List<String> wrappedContent = mc.fontRenderer.listFormattedStringToWidth(msg.messageContent, wrapWidth > 0 ? wrapWidth : 1);
                        String indent = mc.fontRenderer.trimStringToWidth(" ", mc.fontRenderer.getStringWidth(prefix));

                        for (int i = 0; i < wrappedContent.size(); i++) {
                            processedLines.add(Pair.of((i == 0 ? prefix : indent) + wrappedContent.get(i), false));
                        }
                    }
                }
                FONT_CACHE.put(cacheChannelId, processedLines);
            }
            isFontCacheDirty = false;
        }

        finalLines = FONT_CACHE.getOrDefault(currentChannelId, Collections.emptyList());

        int currentFormattedLinesCount = finalLines.size();
        if (interactionGuiOpen && kpkGui != null) {
            boolean wasScrolledToBottom = (maxVisibleLines <= 0) || (kpkGui.getChatScrollOffset() >= this.previousFormattedLinesCount - maxVisibleLines);
            if (currentFormattedLinesCount > this.previousFormattedLinesCount && wasScrolledToBottom) {
                kpkGui.setChatScrollOffset(Integer.MAX_VALUE);
            }
        }
        this.previousFormattedLinesCount = currentFormattedLinesCount;

        int scrollOffset = 0;
        int maxScroll = 0;
        boolean canScroll = finalLines.size() > maxVisibleLines;
        if (interactionGuiOpen && kpkGui != null) {
            scrollOffset = kpkGui.getChatScrollOffset();
            if (canScroll) {
                maxScroll = finalLines.size() - maxVisibleLines;
                scrollOffset = Math.max(0, Math.min(scrollOffset, maxScroll));
                kpkGui.setChatScrollOffset(scrollOffset);
            } else {
                scrollOffset = 0;
                kpkGui.setChatScrollOffset(0);
            }
        }

        Gui.drawRect(chatHistoryX, chatHistoryY, chatHistoryX + chatHistoryWidth, chatHistoryY + chatHistoryHeight, 0x55000000);

        for (int i = 0; i < maxVisibleLines; i++) {
            int lineIndex = i + scrollOffset;
            if (lineIndex >= 0 && lineIndex < finalLines.size()) {
                Pair<String, Boolean> lineData = finalLines.get(lineIndex);
                String line = lineData.getLeft();
                boolean isSelf = lineData.getRight();

                GlStateManager.pushMatrix();
                float yLinePos = chatHistoryY + 2 + (i * chatLineHeight * CHAT_TEXT_SCALE);
                float xLinePos = isSelf ? chatHistoryX + chatHistoryWidth - 2 : chatHistoryX + 2;

                GlStateManager.translate(xLinePos, yLinePos, 0);
                GlStateManager.scale(CHAT_TEXT_SCALE, CHAT_TEXT_SCALE, 1.0f);

                mc.fontRenderer.drawStringWithShadow(line, isSelf ? -mc.fontRenderer.getStringWidth(line) : 0, 0, 0xFFFFFF);
                GlStateManager.popMatrix();
            }
        }

        if (canScroll) {
            int scrollbarX = chatHistoryX + chatHistoryWidth + 2;
            Gui.drawRect(scrollbarX, chatHistoryY, scrollbarX + 2, chatHistoryY + chatHistoryHeight, 0xFF101010);
            int handleHeight = Math.max(10, (int)((float)maxVisibleLines / finalLines.size() * chatHistoryHeight));
            int handleY = chatHistoryY + (int)((float)scrollOffset / maxScroll * (chatHistoryHeight - handleHeight));
            Gui.drawRect(scrollbarX, handleY, scrollbarX + 2, handleY + handleHeight, 0xFF888888);
        }

        if (interactionGuiOpen && kpkGui != null) {
            String currentInput = kpkGui.getCurrentChatInput();
            boolean inputActive = kpkGui.isChatInputActive();
            int cursorBlink = kpkGui.getCursorCounter();
            int inputAreaY = chatInputY + 2;
            int inputFieldHeight = 20;
            int sendButtonWidth = 20;
            int inputFieldWidth = chatHistoryWidth - sendButtonWidth - 2;
            int inputFieldX = chatHistoryX;
            int sendButtonX = inputFieldX + inputFieldWidth + 2;

            drawStyledInputField(inputFieldX, inputAreaY, inputFieldWidth, inputFieldHeight, inputActive);

            String displayText = currentInput;
            if (inputActive && (cursorBlink / 6) % 2 == 0) displayText += "_";

            int availableTextWidth = inputFieldWidth - 6;
            if (mc.fontRenderer.getStringWidth(displayText) > availableTextWidth) {
                displayText = mc.fontRenderer.trimStringToWidth(displayText, availableTextWidth, true);
            }
            mc.fontRenderer.drawStringWithShadow(displayText, inputFieldX + 3, inputAreaY + (inputFieldHeight - mc.fontRenderer.FONT_HEIGHT)/2 + 1, 0xFFEEEEEE);
            modelChatInputFieldRectOnScreen = calculateScreenRectForVirtual(inputFieldX, inputAreaY, inputFieldWidth, inputFieldHeight, mv, proj, vp, sr);

            drawStyledButton(sendButtonX, inputAreaY, sendButtonWidth, inputFieldHeight, COLOR_POSITIVE_TOP, COLOR_POSITIVE_BOTTOM, COLOR_BORDER);
            drawCenteredStringWithShadow(mc.fontRenderer, ">", sendButtonX + sendButtonWidth/2, inputAreaY + (inputFieldHeight - mc.fontRenderer.FONT_HEIGHT)/2, 0xFFFFFFFF);
            modelChatSendButtonRectOnScreen = calculateScreenRectForVirtual(sendButtonX, inputAreaY, sendButtonWidth, inputFieldHeight, mv, proj, vp, sr);
        }
    }

    private void renderMemberList(ItemStack stack, boolean interactionGuiOpen, FloatBuffer mv, FloatBuffer proj, IntBuffer vp, ScaledResolution sr) {
        String currentChannelId = ItemKPK.getCurrentChatChannelId(stack);
        ChatChannel channel = ClientChatCache.getChannel(currentChannelId);

        if (channel == null || channel.getType() == ChatChannelType.COMMON_SERVER_WIDE) {
            return;
        }

        int listX = 230;
        int listY = -45;
        int listWidth = 80;
        int listHeight = 214;
        int itemHeight = 15;
        float textScale = 1.3f;

        Gui.drawRect(listX, listY, listX + listWidth, listY + listHeight, 0x55000000);
        drawCenteredStringWithShadow(mc.fontRenderer, "Участники", listX + listWidth/2, listY + 2, 0xFFAAAAAA);

        if (interactionGuiOpen) {
            modelMemberRemoveButtonRectsOnScreen.clear();
            modelMemberRemoveButtonAssociatedId.clear();
        }

        List<UUID> members = channel.getMembers();
        UUID creatorUuid = channel.getCreatorUuid();
        boolean isLocalPlayerCreator = creatorUuid != null && mc.player != null && creatorUuid.equals(mc.player.getUniqueID());

        for (int i = 0; i < members.size(); i++) {
            UUID memberUuid = members.get(i);
            String callsign = ClientChatCache.getCallsignForUUID(memberUuid);

            boolean isCreator = Objects.equals(memberUuid, creatorUuid);
            String prefix = isCreator ? TextFormatting.GOLD + "[★] " : "";
            String fullText = prefix + TextFormatting.WHITE + callsign;

            int itemY = listY + 12 + i * itemHeight;

            GlStateManager.pushMatrix();
            GlStateManager.translate(listX + 2, itemY, 0);
            GlStateManager.scale(textScale, textScale, 1f);
            mc.fontRenderer.drawString(fullText, 0, 0, 0xFFFFFF);
            GlStateManager.popMatrix();

            if (interactionGuiOpen && isLocalPlayerCreator && !memberUuid.equals(mc.player.getUniqueID()) && channel.getType() == ChatChannelType.PRIVATE_GROUP) {
                int delButtonSize = 10;
                int delButtonX = listX + listWidth - delButtonSize - 2;
                int delButtonY = itemY;
                drawStyledButton(delButtonX, delButtonY, delButtonSize, delButtonSize, COLOR_NEGATIVE_TOP, COLOR_NEGATIVE_BOTTOM, COLOR_BORDER);
                drawCenteredStringWithShadow(mc.fontRenderer, "X", delButtonX + delButtonSize / 2, delButtonY + 1, 0xFFFFFFFF);

                modelMemberRemoveButtonRectsOnScreen.add(calculateScreenRectForVirtual(delButtonX, delButtonY, delButtonSize, delButtonSize, mv, proj, vp, sr));
                modelMemberRemoveButtonAssociatedId.add(memberUuid);
            }
        }
    }

    private void renderChatCreateOverlay(ItemStack stack, boolean interactionGuiOpen, FloatBuffer mv, FloatBuffer proj, IntBuffer vp, ScaledResolution sr) {
        int ccsX = -157;
        int ccsY = 170;
        int btnWidth = 45;
        int btnHeight = 25;
        float scale = 1.5f;

        Gui.drawRect(ccsX - 2, ccsY - 2, ccsX + btnWidth * 2 + 5, ccsY + btnHeight + 2, 0xEE111111);

        drawStyledButton(ccsX, ccsY, btnWidth, btnHeight, COLOR_INACTIVE_TOP, COLOR_INACTIVE_BOTTOM, COLOR_BORDER);
        GlStateManager.pushMatrix();
        String lsText = TextFormatting.BOLD + "ЛС";
        float scaledTextWidth = mc.fontRenderer.getStringWidth(lsText) * scale;
        float scaledTextHeight = mc.fontRenderer.FONT_HEIGHT * scale;
        float textX = ccsX + (btnWidth - scaledTextWidth) / 2.0f;
        float textY = ccsY + (btnHeight - scaledTextHeight) / 2.0f;
        GlStateManager.translate(textX, textY, 0);
        GlStateManager.scale(scale, scale, 1.0f);
        mc.fontRenderer.drawStringWithShadow(lsText, 0, 0, 0xFFAAAAAA);
        GlStateManager.popMatrix();

        if (interactionGuiOpen)
            modelChatCreatePmButtonRectOnScreen = calculateScreenRectForVirtual(ccsX, ccsY, btnWidth, btnHeight, mv, proj, vp, sr);

        ccsX += btnWidth + 3;
        drawStyledButton(ccsX, ccsY, btnWidth, btnHeight, COLOR_INACTIVE_TOP, COLOR_INACTIVE_BOTTOM, COLOR_BORDER);
        GlStateManager.pushMatrix();
        String zkText = TextFormatting.BOLD + "ЗК";
        scaledTextWidth = mc.fontRenderer.getStringWidth(zkText) * scale;
        scaledTextHeight = mc.fontRenderer.FONT_HEIGHT * scale;
        textX = ccsX + (btnWidth - scaledTextWidth) / 2.0f;
        textY = ccsY + (btnHeight - scaledTextHeight) / 2.0f;
        GlStateManager.translate(textX, textY, 0);
        GlStateManager.scale(scale, scale, 1.0f);
        mc.fontRenderer.drawStringWithShadow(zkText, 0, 0, 0xFFAAAAAA);
        GlStateManager.popMatrix();

        if (interactionGuiOpen)
            modelChatCreateGroupButtonRectOnScreen = calculateScreenRectForVirtual(ccsX, ccsY, btnWidth, btnHeight, mv, proj, vp, sr);
    }

    private void renderContactSelection(ItemStack stack, boolean interactionGuiOpen, FloatBuffer mv, FloatBuffer proj, IntBuffer vp, ScaledResolution sr) {
        int creationType = ItemKPK.getChatCreationType(stack);
        String title = (creationType == ItemKPK.CHAT_TYPE_PM) ? "Выберите контакт для ЛС" : "Выберите до 2 контактов для ЗК";
        drawCenteredStringWithShadow(mc.fontRenderer, TextFormatting.GOLD + "" + TextFormatting.BOLD + title, 80, -45, 0xFFD700);

        List<String> selectedContacts = ItemKPK.getSelectedContactsForGroup(stack);
        List<String> allContacts = ItemKPK.getContacts(stack);

        if (interactionGuiOpen) {
            modelContactDeleteButtonRectsOnScreen.clear();
            modelContactDeleteButtonAssociatedName.clear();
        }

        int gridStartX = -157;
        int contactListStartY = -25;
        int cellWidth = 148;
        int cellHeight = 22;
        int horizontalSpacing = 10;
        int verticalSpacing = 5;
        int numColumns = 2;

        for (int i = 0; i < Math.min(allContacts.size(), 10); i++) {
            int row = i / numColumns;
            int col = i % numColumns;

            int cellX = gridStartX + col * (cellWidth + horizontalSpacing);
            int cellY = contactListStartY + row * (cellHeight + verticalSpacing);
            String contactName = allContacts.get(i);
            boolean isSelected = selectedContacts.contains(contactName);

            int borderColor = isSelected ? 0xFF00AA00 : 0xFFFFFFFF;
            int bgColor = 0x99000000;
            Gui.drawRect(cellX - 1, cellY - 1, cellX + cellWidth + 1, cellY + cellHeight + 1, borderColor);
            Gui.drawRect(cellX, cellY, cellX + cellWidth, cellY + cellHeight, bgColor);
            drawCenteredStringWithShadow(mc.fontRenderer, contactName, cellX + cellWidth / 2, cellY + (cellHeight - 8) / 2, 0xFFFFFF);

            if (interactionGuiOpen) {
                modelContactDeleteButtonRectsOnScreen.add(calculateScreenRectForVirtual(cellX, cellY, cellWidth, cellHeight, mv, proj, vp, sr));
                modelContactDeleteButtonAssociatedName.add(contactName);
            }
        }

        if (creationType == ItemKPK.CHAT_TYPE_GROUP && interactionGuiOpen) {
            int confirmButtonWidth = 100;
            int confirmButtonHeight = 18;
            int confirmButtonX = 32;
            int confirmButtonY = 179;
            boolean canConfirm = !selectedContacts.isEmpty();

            if (canConfirm) {
                drawStyledButton(confirmButtonX, confirmButtonY, confirmButtonWidth, confirmButtonHeight, COLOR_POSITIVE_TOP, COLOR_POSITIVE_BOTTOM, COLOR_BORDER);
            } else {
                drawStyledButton(confirmButtonX, confirmButtonY, confirmButtonWidth, confirmButtonHeight, COLOR_INACTIVE_TOP, COLOR_INACTIVE_BOTTOM, COLOR_BORDER);
            }
            drawCenteredStringWithShadow(mc.fontRenderer, "Создать Канал", confirmButtonX + confirmButtonWidth/2, confirmButtonY + (confirmButtonHeight - 8)/2, canConfirm ? 0xFFFFFFFF : 0xFFAAAAAA);
            modelContactsConfirmAddRectOnScreen = calculateScreenRectForVirtual(confirmButtonX, confirmButtonY, confirmButtonWidth, confirmButtonHeight, mv, proj, vp, sr);
        } else {
            modelContactsConfirmAddRectOnScreen = null;
        }
    }

    private void renderContactList(ItemStack stack, boolean interactionGuiOpen, FloatBuffer mv, FloatBuffer proj, IntBuffer vp, ScaledResolution sr) {
        FontRenderer fontRenderer = mc.fontRenderer;
        int contactsPageTitleY = -45;
        drawCenteredStringWithShadow(fontRenderer, TextFormatting.GOLD + "" + TextFormatting.BOLD + "СПИСОК КОНТАКТОВ", 80, contactsPageTitleY, 0xFFD700);

        if (interactionGuiOpen) {
            modelContactDeleteButtonRectsOnScreen.clear();
            modelContactDeleteButtonAssociatedName.clear();
        }

        if (mc.player == null) return;

        KPKModelInteractionGui kpkGui = null;
        boolean isContactAddModeActiveForGui = false;
        if (interactionGuiOpen && mc.currentScreen instanceof KPKModelInteractionGui) {
            kpkGui = (KPKModelInteractionGui) mc.currentScreen;
            isContactAddModeActiveForGui = kpkGui.isAddingContact();
        }

        if (isContactAddModeActiveForGui && kpkGui != null) {
            String currentInput = kpkGui.getCurrentContactInput();
            boolean inputActive = kpkGui.isContactInputActive();
            int cursorBlink = kpkGui.getCursorCounter();

            int inputFieldHeight = 18;
            int inputFieldY = 179;
            int inputFieldX = -70;
            int inputFieldWidth = 280;
            int confirmButtonWidth = 20;

            drawStyledInputField(inputFieldX, inputFieldY, inputFieldWidth, inputFieldHeight, inputActive);

            String displayText = currentInput;
            if (inputActive && (cursorBlink / 6) % 2 == 0) displayText += "_";
            fontRenderer.drawStringWithShadow(displayText, inputFieldX + 3, inputFieldY + (inputFieldHeight - fontRenderer.FONT_HEIGHT)/2 + 1, 0xFFFFFFFF);
            modelContactsInputFieldRectOnScreen = calculateScreenRectForVirtual(inputFieldX, inputFieldY, inputFieldWidth, inputFieldHeight, mv, proj, vp, sr);

            int confirmButtonX = inputFieldX + inputFieldWidth + 2;
            drawStyledButton(confirmButtonX, inputFieldY, confirmButtonWidth, inputFieldHeight, COLOR_POSITIVE_TOP, COLOR_POSITIVE_BOTTOM, COLOR_BORDER);
            drawCenteredStringWithShadow(fontRenderer, "+", confirmButtonX + confirmButtonWidth/2, inputFieldY + (inputFieldHeight - fontRenderer.FONT_HEIGHT)/2 + 1, 0xFFFFFFFF);
            modelContactsConfirmAddRectOnScreen = calculateScreenRectForVirtual(confirmButtonX, inputFieldY, confirmButtonWidth, inputFieldHeight, mv, proj, vp, sr);
        } else {
            List<String> playerContacts = ItemKPK.getContacts(stack);
            int contactListStartY = -25;

            if (playerContacts.isEmpty()) {
                fontRenderer.drawStringWithShadow(TextFormatting.GRAY + "(Пусто)", -150, contactListStartY, 0xAAAAAA);
            } else {
                int gridStartX = -157;
                int cellWidth = 148;
                int cellHeight = 22;
                int horizontalSpacing = 10;
                int verticalSpacing = 5;
                int numColumns = 2;

                for (int i = 0; i < Math.min(playerContacts.size(), 10); i++) {
                    int row = i / numColumns;
                    int col = i % numColumns;

                    int cellX = gridStartX + col * (cellWidth + horizontalSpacing);
                    int cellY = contactListStartY + row * (cellHeight + verticalSpacing);
                    String contactName = playerContacts.get(i);
                    int delButtonSize = 10;
                    int delButtonX = cellX + cellWidth - delButtonSize - 2;
                    int delButtonY = cellY + (cellHeight - delButtonSize) / 2;

                    Gui.drawRect(cellX - 1, cellY - 1, cellX + cellWidth + 1, cellY + cellHeight + 1, 0xFFFFFFFF);
                    Gui.drawRect(cellX, cellY, cellX + cellWidth, cellY + cellHeight, 0x99000000);
                    fontRenderer.drawStringWithShadow(contactName, cellX + 4, cellY + (cellHeight - fontRenderer.FONT_HEIGHT) / 2 + 1, 0xFFFFFF);

                    if (interactionGuiOpen) {
                        drawStyledButton(delButtonX, delButtonY, delButtonSize, delButtonSize, COLOR_NEGATIVE_TOP, COLOR_NEGATIVE_BOTTOM, COLOR_BORDER);
                        fontRenderer.drawStringWithShadow("X", delButtonX + 2, delButtonY + 1, 0xFFFFFFFF);
                        modelContactDeleteButtonRectsOnScreen.add(calculateScreenRectForVirtual(delButtonX, delButtonY, delButtonSize, delButtonSize, mv, proj, vp, sr));
                        modelContactDeleteButtonAssociatedName.add(contactName);
                    }
                }
            }

            if (interactionGuiOpen) {
                modelContactsInputFieldRectOnScreen = null;
                modelContactsConfirmAddRectOnScreen = null;
                int addContactButtonWidth = 100;
                int addContactButtonHeight = 18;
                int addContactButtonX = 32;
                int addContactButtonY = 179;

                drawStyledButton(addContactButtonX, addContactButtonY, addContactButtonWidth, addContactButtonHeight, COLOR_INACTIVE_TOP, COLOR_INACTIVE_BOTTOM, COLOR_BORDER);
                drawCenteredStringWithShadow(fontRenderer, "Добавить контакт", addContactButtonX + addContactButtonWidth/2, addContactButtonY + (addContactButtonHeight - fontRenderer.FONT_HEIGHT)/2 + 1, 0xFFFFFFFF);
                modelContactsAddButtonRectOnScreen = calculateScreenRectForVirtual(addContactButtonX, addContactButtonY, addContactButtonWidth, addContactButtonHeight, mv, proj, vp, sr);
            }
        }
    }

    private void drawCenteredStringWithShadow(FontRenderer fontRendererIn, String text, int x, int y, int color) {
        fontRendererIn.drawStringWithShadow(text, (float)(x - fontRendererIn.getStringWidth(text) / 2), (float)y, color);
    }

    private static Rectangle calculateScreenRectForVirtual(float virtualX, float virtualY, float virtualWidth, float virtualHeight,
                                                           FloatBuffer modelView, FloatBuffer projection, IntBuffer viewport, ScaledResolution sr) {
        if (modelView == null || projection == null || viewport == null || sr == null) return null;

        float[] topLeft = projectToScreenSpaceForRect(virtualX, virtualY, 0, modelView, projection, viewport, sr);
        float[] bottomRight = projectToScreenSpaceForRect(virtualX + virtualWidth, virtualY + virtualHeight, 0, modelView, projection, viewport, sr);

        if (topLeft != null && bottomRight != null) {
            if (topLeft[2] < 1.0f && bottomRight[2] < 1.0f) {
                float rX1 = Math.min(topLeft[0], bottomRight[0]);
                float rY1 = Math.min(topLeft[1], bottomRight[1]);
                float rX2 = Math.max(topLeft[0], bottomRight[0]);
                float rY2 = Math.max(topLeft[1], bottomRight[1]);
                return new Rectangle((int)rX1, (int)rY1, (int)(rX2 - rX1), (int)(rY2 - rY1));
            }
        }
        return null;
    }

    private static float[] projectToScreenSpaceForRect(float x, float y, float z,
                                                       FloatBuffer modelViewMatrix, FloatBuffer projectionMatrix, IntBuffer viewport,
                                                       ScaledResolution sr) {
        FloatBuffer screenCoords = BufferUtils.createFloatBuffer(3);
        if (GLU.gluProject(x, y, z, modelViewMatrix, projectionMatrix, viewport, screenCoords)) {
            float screenX = screenCoords.get(0);
            float screenY = mc.displayHeight - screenCoords.get(1);
            return new float[]{screenX / sr.getScaleFactor(), screenY / sr.getScaleFactor(), screenCoords.get(2)};
        }
        return null;
    }

    private void applyTabletTransform(ItemCameraTransforms.TransformType transformType) {
        switch (transformType) {
            case FIRST_PERSON_RIGHT_HAND:
            case FIRST_PERSON_LEFT_HAND:
                GlStateManager.translate(0.0F, 0.4F, -1F);
                GlStateManager.rotate(180F, 0, 1, 0);
                GlStateManager.rotate(0F, 1, 0, 0);
                GlStateManager.rotate(33F, 0, 0, 1);
                GlStateManager.scale(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE);
                break;
            case THIRD_PERSON_RIGHT_HAND:
            case THIRD_PERSON_LEFT_HAND:
                GlStateManager.translate(1.3F, -0.1F, 0.7F);
                GlStateManager.rotate(90F, 0, 1, 0);
                GlStateManager.rotate(0F, 1, 0, 0);
                GlStateManager.rotate(15f, 0, 0, 1);
                GlStateManager.scale(MODEL_SCALE * 0.7F, MODEL_SCALE * 0.7F, MODEL_SCALE * 0.7F);
                break;
            case GROUND:
                GlStateManager.translate(0.0F, 0.0F, 0.0F);
                GlStateManager.scale(MODEL_SCALE * 0.5F, MODEL_SCALE * 0.5F, MODEL_SCALE * 0.5F);
                break;
            case GUI:
                GlStateManager.translate(0.0F, 0.0F, 0.0F);
                GlStateManager.rotate(30F, 1, 0, 0);
                GlStateManager.rotate(225F, 0, 1, 0);
                GlStateManager.scale(MODEL_SCALE * 1.2F, MODEL_SCALE * 1.2F, MODEL_SCALE * 1.2F);
                break;
            default:
                GlStateManager.scale(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE);
                break;
        }
    }

    public static void setTransformType(ItemCameraTransforms.TransformType transform) {
        currentTransform = transform;
    }
}===== com/example/examplemod/item/ModItems.java =====
package com.example.examplemod.item;

import com.example.examplemod.ExampleMod;
import net.minecraft.client.renderer.block.model.ModelResourceLocation;
import net.minecraft.item.Item;
import net.minecraftforge.client.event.ModelRegistryEvent;
import net.minecraftforge.client.model.ModelLoader;
import net.minecraftforge.event.RegistryEvent;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.List;

@Mod.EventBusSubscriber(modid = ExampleMod.MODID)
public class ModItems {
    public static final ItemKPK KPK_DEVICE = new ItemKPK();

    public static final List<Item> ITEMS = new ArrayList<>();

    static {
        ITEMS.add(KPK_DEVICE);
    }

    /**
     * Called automatically by Forge at RegistryEvent.Register<Item>.
     * Instead of doing event.getRegistry().register(...) per‐item, we do registerAll(...) over the entire list.
     */
    @SubscribeEvent
    public static void registerItems(RegistryEvent.Register<Item> event) {
        Item[] array = ITEMS.toArray(new Item[0]);
        event.getRegistry().registerAll(array);
        System.out.println("=== REGISTERED ITEMS ===");
        for (Item i : ITEMS) {
            System.out.println("→ " + i.getRegistryName());
        }
    }
}===== com/example/examplemod/kpk/CapabilityHandler.java =====
package com.example.examplemod.kpk;

import com.example.examplemod.ExampleMod;
import com.example.examplemod.chat.ChatManager;
import com.example.examplemod.network.PacketHandler;
import com.example.examplemod.network.PacketSyncKpkDatabaseToClient;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

@Mod.EventBusSubscriber(modid = ExampleMod.MODID)
public class CapabilityHandler {

    @SubscribeEvent
    public static void onPlayerLogin(net.minecraftforge.fml.common.gameevent.PlayerEvent.PlayerLoggedInEvent event) {
        EntityPlayer player = event.player;
        if (!player.world.isRemote && player instanceof EntityPlayerMP) {
            EntityPlayerMP playerMP = (EntityPlayerMP) player;
            // Синхронизируем чаты как и раньше
            ChatManager.onPlayerLogin(playerMP);
            // А теперь дополнительно отправляем всю базу данных КПК
            PacketHandler.INSTANCE.sendTo(new PacketSyncKpkDatabaseToClient(KPKServerManager.getFullKpkDatabase()), playerMP);
        }
    }
}===== com/example/examplemod/kpk/CommandKPKSet.java =====
package com.example.examplemod.command;

import com.example.examplemod.Gender;
import com.example.examplemod.User;
import com.example.examplemod.item.ItemKPK;
import com.example.examplemod.item.ModItems;
import com.example.examplemod.kpk.KPKServerManager;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextFormatting;
import org.apache.commons.lang3.tuple.Pair;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class CommandKPKSet extends CommandBase {

    @Override
    public String getName() {
        return "kpk";
    }

    @Override
    public String getUsage(ICommandSender sender) {
        return "/kpk set <Фамилия> <Имя> <Позывной> <Дата_рождения> <Пол>\n" +
                "/kpk get <игрок/позывной>\n" +
                "/kpk check\n" +
                "/kpk listcontacts\n" +
                "/kpk give";
    }

    @Override
    public int getRequiredPermissionLevel() {
        return 0;
    }

    @Override
    public void execute(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException {
        if (!(sender instanceof EntityPlayer)) {
            sender.sendMessage(new TextComponentString(TextFormatting.RED + "Эта команда доступна только игрокам!"));
            return;
        }

        EntityPlayer player = (EntityPlayer) sender;

        if (args.length < 1) {
            throw new CommandException(getUsage(sender));
        }

        switch (args[0].toLowerCase()) {
            case "set":
                handleSet(player, args);
                break;
            case "get":
                handleGet(player, server, args);
                break;
            case "check":
                handleCheck(player);
                break;
            case "listcontacts":
                handleListContacts(player);
                break;
            case "give":
                handleGive(player);
                break;
            default:
                throw new CommandException("Неизвестная подкоманда. " + getUsage(sender));
        }
    }

    private void handleGive(EntityPlayer player) {
        ItemStack kpkItem = new ItemStack(ModItems.KPK_DEVICE);
        player.inventory.addItemStackToInventory(kpkItem);
        player.sendMessage(new TextComponentString(TextFormatting.GOLD + "Вы получили КПК устройство!"));
    }

    private void handleSet(EntityPlayer player, String[] args) throws CommandException {
        ItemStack heldStack = player.getHeldItemMainhand();
        if (!(heldStack.getItem() instanceof ItemKPK)) {
            throw new CommandException("Вы должны держать КПК в основной руке, чтобы настроить его.");
        }

        if (args.length != 6) {
            throw new CommandException("Использование: /kpk set <Фамилия> <Имя> <Позывной> <Дата_рождения> <Пол>");
        }

        String familiya = args[1];
        String name = args[2];
        String pozivnoy = args[3];
        String birthdateStr = args[4];
        String genderStr = args[5];

        if (KPKServerManager.findUserByCallsign(pozivnoy) != null) {
            throw new CommandException("Этот позывной уже занят.");
        }

        LocalDate birthdate;
        try {
            birthdate = LocalDate.parse(birthdateStr, DateTimeFormatter.ofPattern("dd.MM.yyyy"));
        } catch (DateTimeParseException e) {
            throw new CommandException("Неверный формат даты! Используйте формат: дд.мм.гггг");
        }

        Gender gender = Gender.fromString(genderStr);
        if (gender == null) {
            throw new CommandException("Неверный пол! Используйте: м/ж");
        }

        User user = new User(familiya, name, pozivnoy, gender, birthdate);

        // 1. Записываем данные в предмет
        ItemKPK.setUserData(heldStack, user);
        ItemKPK.setContacts(heldStack, new ArrayList<>());

        // 2. Записываем данные в центральное серверное хранилище
        KPKServerManager.setUser(player.getUniqueID(), user);

        player.sendMessage(new TextComponentString(TextFormatting.GREEN + "Данные КПК успешно установлены и зарегистрированы на сервере!"));
    }

    private void handleGet(EntityPlayer sender, MinecraftServer server, String[] args) throws CommandException {
        if (args.length != 2) {
            throw new CommandException("Использование: /kpk get <игрок/позывной>");
        }

        String targetIdentifier = args[1];
        User targetUser = null;

        EntityPlayer targetPlayer = server.getPlayerList().getPlayerByUsername(targetIdentifier);
        if (targetPlayer != null) {
            targetUser = KPKServerManager.getUser(targetPlayer.getUniqueID());
        } else {
            Pair<UUID, User> foundUser = KPKServerManager.findUserByCallsign(targetIdentifier);
            if (foundUser != null) {
                targetUser = foundUser.getRight();
            }
        }

        if (targetUser == null) {
            throw new CommandException("Игрок или позывной '" + targetIdentifier + "' не найден в базе данных КПК.");
        }

        displayUserData(sender, targetUser.pozivnoy, targetUser);
    }

    private void handleCheck(EntityPlayer player) throws CommandException {
        User user = KPKServerManager.getUser(player.getUniqueID());
        if (user == null) {
            throw new CommandException("Ваши данные не найдены в базе. Используйте /kpk set.");
        }
        displayUserData(player, "Ваши", user);
    }

    private void handleListContacts(EntityPlayer player) throws CommandException {
        ItemStack heldStack = player.getHeldItemMainhand();
        if (!(heldStack.getItem() instanceof ItemKPK)) {
            throw new CommandException("Вы должны держать КПК в основной руке.");
        }

        List<String> contacts = ItemKPK.getContacts(heldStack);
        if (contacts.isEmpty()) {
            player.sendMessage(new TextComponentString(TextFormatting.YELLOW + "Список контактов этого КПК пуст."));
        } else {
            player.sendMessage(new TextComponentString(TextFormatting.GREEN + "Контакты в этом КПК:"));
            for (String contact : contacts) {
                player.sendMessage(new TextComponentString("- " + contact));
            }
        }
    }

    private void displayUserData(ICommandSender sender, String ownerName, User userData) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd.MM.yyyy");
        sender.sendMessage(new TextComponentString(TextFormatting.GREEN + "=== КПК данные (" + ownerName + ") ==="));
        sender.sendMessage(new TextComponentString(TextFormatting.AQUA + "Фамилия: " + TextFormatting.WHITE + userData.familiya));
        sender.sendMessage(new TextComponentString(TextFormatting.AQUA + "Имя: " + TextFormatting.WHITE + userData.name));
        sender.sendMessage(new TextComponentString(TextFormatting.AQUA + "Позывной: " + TextFormatting.WHITE + userData.pozivnoy));
        sender.sendMessage(new TextComponentString(TextFormatting.AQUA + "Дата рождения: " + TextFormatting.WHITE + userData.birthdate.format(formatter)));
        sender.sendMessage(new TextComponentString(TextFormatting.AQUA + "Пол: " + TextFormatting.WHITE + userData.gender.getDisplayName()));
    }
}===== com/example/examplemod/kpk/KPKDataStore.java =====
package com.example.examplemod.kpk;

import com.example.examplemod.Gender;
import com.example.examplemod.User;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.world.storage.WorldSavedData;
import net.minecraftforge.common.util.Constants;
import org.apache.commons.lang3.tuple.Pair;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class KPKDataStore extends WorldSavedData {

    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy");
    private final Map<UUID, User> playerData = new ConcurrentHashMap<>();

    public KPKDataStore(String name) {
        super(name);
    }

    public void setUserData(UUID uuid, User user) {
        if (user == null) {
            playerData.remove(uuid);
        } else {
            playerData.put(uuid, user);
        }
        markDirty();
    }

    public User getUserData(UUID uuid) {
        return playerData.get(uuid);
    }

    public Map<UUID, User> getFullDatabase() {
        return Collections.unmodifiableMap(playerData);
    }

    public Pair<UUID, User> findUserByCallsign(String callsign) {
        if (callsign == null || callsign.isEmpty()) {
            return null;
        }
        for (Map.Entry<UUID, User> entry : playerData.entrySet()) {
            if (callsign.equalsIgnoreCase(entry.getValue().pozivnoy)) {
                return Pair.of(entry.getKey(), entry.getValue());
            }
        }
        return null;
    }

    @Override
    public void readFromNBT(NBTTagCompound nbt) {
        playerData.clear();
        NBTTagList playerList = nbt.getTagList("PlayerData", Constants.NBT.TAG_COMPOUND);
        for (int i = 0; i < playerList.tagCount(); i++) {
            NBTTagCompound playerTag = playerList.getCompoundTagAt(i);
            try {
                UUID uuid = UUID.fromString(playerTag.getString("UUID"));
                User user = new User(
                        playerTag.getString("familiya"),
                        playerTag.getString("name"),
                        playerTag.getString("pozivnoy"),
                        Gender.valueOf(playerTag.getString("gender")),
                        LocalDate.parse(playerTag.getString("birthdate"), DATE_FORMATTER)
                );
                playerData.put(uuid, user);
            } catch (Exception e) {
                System.err.println("Could not load KPK user data from NBT: " + e.getMessage());
            }
        }
    }

    @Override
    public NBTTagCompound writeToNBT(NBTTagCompound compound) {
        NBTTagList playerList = new NBTTagList();
        for (Map.Entry<UUID, User> entry : playerData.entrySet()) {
            NBTTagCompound playerTag = new NBTTagCompound();
            User user = entry.getValue();
            playerTag.setString("UUID", entry.getKey().toString());
            playerTag.setString("familiya", user.familiya);
            playerTag.setString("name", user.name);
            playerTag.setString("pozivnoy", user.pozivnoy);
            playerTag.setString("gender", user.gender.name());
            playerTag.setString("birthdate", user.birthdate.format(DATE_FORMATTER));
            playerList.appendTag(playerTag);
        }
        compound.setTag("PlayerData", playerList);
        return compound;
    }
}===== com/example/examplemod/kpk/KPKServerManager.java =====
package com.example.examplemod.kpk;

import com.example.examplemod.User;
import net.minecraft.server.MinecraftServer;
import net.minecraft.world.storage.MapStorage;
import org.apache.commons.lang3.tuple.Pair;

import java.util.Map;
import java.util.UUID;

public class KPKServerManager {

    private static final String DATA_NAME = "examplemod_kpk_data";
    private static KPKDataStore dataStore;

    public static void load(MinecraftServer server) {
        MapStorage storage = server.getWorld(0).getMapStorage();
        dataStore = (KPKDataStore) storage.getOrLoadData(KPKDataStore.class, DATA_NAME);
        if (dataStore == null) {
            dataStore = new KPKDataStore(DATA_NAME);
            storage.setData(DATA_NAME, dataStore);
        }
        System.out.println("[ExampleMod] KPKServerManager loaded.");
    }

    public static void save(MinecraftServer server) {
        if (dataStore != null) {
            MapStorage storage = server.getWorld(0).getMapStorage();
            storage.setData(DATA_NAME, dataStore);
            System.out.println("[ExampleMod] KPKServerManager data saved.");
        }
    }

    public static void setUser(UUID uuid, User user) {
        if (dataStore != null) {
            dataStore.setUserData(uuid, user);
        }
    }

    public static User getUser(UUID uuid) {
        return dataStore != null ? dataStore.getUserData(uuid) : null;
    }

    public static Map<UUID, User> getFullKpkDatabase() {
        return dataStore.getFullDatabase();
    }

    public static Pair<UUID, User> findUserByCallsign(String callsign) {
        return dataStore != null ? dataStore.findUserByCallsign(callsign) : null;
    }
}===== com/example/examplemod/model/CustomKPKModel.java =====
package com.example.examplemod.model;

import com.example.examplemod.item.ItemKPKRenderer;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.block.model.BakedQuad;
import net.minecraft.client.renderer.block.model.IBakedModel;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
import net.minecraft.client.renderer.block.model.ItemOverrideList;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.item.ItemStack;
import net.minecraft.util.EnumFacing;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.commons.lang3.tuple.Pair;

import javax.annotation.Nullable;
import javax.vecmath.Matrix4f;
import java.util.List;

@SideOnly(Side.CLIENT)
public class CustomKPKModel implements IBakedModel {
    private final IBakedModel baseModel;
    private final ItemOverrideList overrides;
    private ItemCameraTransforms.TransformType currentTransform = ItemCameraTransforms.TransformType.NONE;

    public CustomKPKModel(IBakedModel baseModel) {
        this.baseModel = baseModel;
        this.overrides = new ItemOverrideList(baseModel.getOverrides().getOverrides()) {
            @Override
            public IBakedModel handleItemState(IBakedModel originalModel, ItemStack stack,
                                               @Nullable World world, @Nullable EntityLivingBase entity) {
                return CustomKPKModel.this;
            }
        };
    }

    @Override
    public List<BakedQuad> getQuads(@Nullable IBlockState state, @Nullable EnumFacing side, long rand) {
        return baseModel.getQuads(state, side, rand);
    }

    @Override
    public boolean isAmbientOcclusion() {
        return baseModel.isAmbientOcclusion();
    }

    @Override
    public boolean isGui3d() {
        return true;
    }

    @Override
    public boolean isBuiltInRenderer() {
        return currentTransform != ItemCameraTransforms.TransformType.GUI &&
                currentTransform != ItemCameraTransforms.TransformType.FIXED &&
                currentTransform != ItemCameraTransforms.TransformType.NONE;
    }

    @Override
    public TextureAtlasSprite getParticleTexture() {
        return baseModel.getParticleTexture();
    }

    @Override
    public ItemOverrideList getOverrides() {
        return overrides;
    }

    @Override
    public Pair<? extends IBakedModel, Matrix4f> handlePerspective(ItemCameraTransforms.TransformType cameraTransformType) {
        this.currentTransform = cameraTransformType;
        if (Minecraft.getMinecraft().getRenderItem() != null) {
            ItemKPKRenderer.setTransformType(cameraTransformType);
        }

        return Pair.of(this, baseModel.handlePerspective(cameraTransformType).getRight());
    }
}===== com/example/examplemod/model/ModelBakeHandler.java =====
package com.example.examplemod.model;

import com.example.examplemod.ExampleMod;
import net.minecraft.client.renderer.block.model.IBakedModel;
import net.minecraft.client.renderer.block.model.ModelResourceLocation;
import net.minecraft.util.registry.IRegistry;
import net.minecraftforge.client.event.ModelBakeEvent;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@Mod.EventBusSubscriber(modid = ExampleMod.MODID, value = Side.CLIENT)
public class ModelBakeHandler {

    @SubscribeEvent
    @SideOnly(Side.CLIENT)
    public static void onModelBake(ModelBakeEvent event) {
        IRegistry<ModelResourceLocation, IBakedModel> registry = event.getModelRegistry();

        ModelResourceLocation kpkModelLocation = new ModelResourceLocation(
                ExampleMod.MODID + ":kpk_device", "inventory");

        IBakedModel originalModel = registry.getObject(kpkModelLocation);

        if (originalModel != null) {
            CustomKPKModel customModel = new CustomKPKModel(originalModel);

            registry.putObject(kpkModelLocation, customModel);

            System.out.println("Successfully wrapped KPK model with custom renderer");
        } else {
            System.err.println("Could not find KPK model to wrap!");
        }
    }
}===== com/example/examplemod/model/TextureRegistry.java =====
package com.example.examplemod.model;

import com.example.examplemod.ExampleMod;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.client.event.TextureStitchEvent;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@Mod.EventBusSubscriber(modid = ExampleMod.MODID, value = Side.CLIENT)
public class TextureRegistry {

    @SubscribeEvent
    @SideOnly(Side.CLIENT)
    public static void onTextureStitch(TextureStitchEvent.Pre event) {
        TextureMap textureMap = event.getMap();

        textureMap.registerSprite(new ResourceLocation(ExampleMod.MODID, "items/kpk_item"));

        System.out.println("Registered texture: " + ExampleMod.MODID + ":items/kpk_item");
    }
}===== com/example/examplemod/network/PacketAddContactRequest.java =====
package com.example.examplemod.network;

import com.example.examplemod.User;
import com.example.examplemod.item.ItemKPK;
import com.example.examplemod.kpk.KPKServerManager;
import io.netty.buffer.ByteBuf;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.EnumHand;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextFormatting;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;
import org.apache.commons.lang3.tuple.Pair;

import java.util.List;
import java.util.UUID;

public class PacketAddContactRequest implements IMessage {

    private String targetCallsign;

    public PacketAddContactRequest() {}

    public PacketAddContactRequest(String targetCallsign) {
        this.targetCallsign = targetCallsign;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        this.targetCallsign = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBytes(ByteBuf buf) {
        ByteBufUtils.writeUTF8String(buf, this.targetCallsign);
    }

    public static class Handler implements IMessageHandler<PacketAddContactRequest, IMessage> {
        @Override
        public IMessage onMessage(PacketAddContactRequest message, MessageContext ctx) {
            EntityPlayerMP player = ctx.getServerHandler().player;
            MinecraftServer server = player.getServer();

            server.addScheduledTask(() -> {
                System.out.println("[KPK-DEBUG] Received PacketAddContactRequest for callsign: " + message.targetCallsign);

                EnumHand hand = EnumHand.MAIN_HAND;
                ItemStack kpkStack = player.getHeldItemMainhand();

                if (!(kpkStack.getItem() instanceof ItemKPK)) {
                    kpkStack = player.getHeldItemOffhand();
                    hand = EnumHand.OFF_HAND;
                }

                if (!(kpkStack.getItem() instanceof ItemKPK)) {
                    player.sendMessage(new TextComponentString(TextFormatting.RED + "Вы должны держать КПК в руке."));
                    System.out.println("[KPK-DEBUG] Player is not holding a KPK.");
                    return;
                }

                User playerUser = ItemKPK.getUserData(kpkStack);
                if (playerUser == null) {
                    player.sendMessage(new TextComponentString(TextFormatting.RED + "Ваш КПК не настроен."));
                    System.out.println("[KPK-DEBUG] Player's KPK is not configured.");
                    return;
                }
                if (message.targetCallsign.equalsIgnoreCase(playerUser.pozivnoy)) {
                    player.sendMessage(new TextComponentString(TextFormatting.RED + "Вы не можете добавить себя в контакты."));
                    System.out.println("[KPK-DEBUG] Player tried to add self.");
                    return;
                }

                List<String> currentContacts = ItemKPK.getContacts(kpkStack);
                if (currentContacts.contains(message.targetCallsign)) {
                    player.sendMessage(new TextComponentString(TextFormatting.YELLOW + "Позывной '" + message.targetCallsign + "' уже в контактах этого КПК."));
                    System.out.println("[KPK-DEBUG] Contact already exists.");
                    return;
                }
                System.out.println("[KPK-DEBUG] Pre-add contacts: " + currentContacts.toString());

                Pair<UUID, User> targetUserPair = KPKServerManager.findUserByCallsign(message.targetCallsign);

                if (targetUserPair != null) {
                    System.out.println("[KPK-DEBUG] Found user by callsign: " + targetUserPair.getRight().pozivnoy + " with UUID " + targetUserPair.getLeft());

                    ItemKPK.addContact(kpkStack, message.targetCallsign);

                    System.out.println("[KPK-DEBUG] Post-add contacts: " + ItemKPK.getContacts(kpkStack).toString());

                    player.sendMessage(new TextComponentString(TextFormatting.GREEN + "Контакт '" + message.targetCallsign + "' добавлен в ваш КПК."));

                    player.setHeldItem(hand, kpkStack);
                    player.inventory.markDirty();
                    System.out.println("[KPK-DEBUG] Updated and synced ItemStack in hand: " + hand.name());

                } else {
                    player.sendMessage(new TextComponentString(TextFormatting.RED + "Пользователь с позывным '" + message.targetCallsign + "' не зарегистрирован в базе данных сервера."));
                    System.out.println("[KPK-DEBUG] User not found in KPKServerManager for callsign: " + message.targetCallsign);
                }
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketBroadcastChatMessageToClient.java =====
package com.example.examplemod.network;

import com.example.examplemod.chat.ChatMessage;
import com.example.examplemod.chat.ClientChatCache;
import io.netty.buffer.ByteBuf;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class PacketBroadcastChatMessageToClient implements IMessage {
    private ChatMessage chatMessage;

    public PacketBroadcastChatMessageToClient() {}

    public PacketBroadcastChatMessageToClient(ChatMessage chatMessage) {
        this.chatMessage = chatMessage;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        this.chatMessage = ChatMessage.fromBytes(buf);
    }

    @Override
    public void toBytes(ByteBuf buf) {
        this.chatMessage.toBytes(buf);
    }

    public static class Handler implements IMessageHandler<PacketBroadcastChatMessageToClient, IMessage> {
        @Override
        @SideOnly(Side.CLIENT)
        public IMessage onMessage(PacketBroadcastChatMessageToClient message, MessageContext ctx) {
            Minecraft.getMinecraft().addScheduledTask(() -> {
                ClientChatCache.addMessage(message.chatMessage);
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketChatMessageToServer.java =====
package com.example.examplemod.network;

import com.example.examplemod.User;
import com.example.examplemod.chat.ChatMessage;
import com.example.examplemod.chat.ChatManager;
import com.example.examplemod.item.ItemKPK;
import io.netty.buffer.ByteBuf;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextFormatting;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;

public class PacketChatMessageToServer implements IMessage {
    private String channelId;
    private String content;

    public PacketChatMessageToServer() {}

    public PacketChatMessageToServer(String channelId, String content) {
        this.channelId = channelId;
        this.content = content;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        this.channelId = ByteBufUtils.readUTF8String(buf);
        this.content = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBytes(ByteBuf buf) {
        ByteBufUtils.writeUTF8String(buf, this.channelId);
        ByteBufUtils.writeUTF8String(buf, this.content);
    }

    public static class Handler implements IMessageHandler<PacketChatMessageToServer, IMessage> {
        @Override
        public IMessage onMessage(PacketChatMessageToServer message, MessageContext ctx) {
            EntityPlayerMP player = ctx.getServerHandler().player;
            player.getServer().addScheduledTask(() -> {
                ItemStack kpkStack = player.getHeldItemMainhand();
                if (!(kpkStack.getItem() instanceof ItemKPK) || !ItemKPK.isEnabled(kpkStack)) {
                    kpkStack = player.getHeldItemOffhand();
                }

                if (!(kpkStack.getItem() instanceof ItemKPK) || !ItemKPK.isEnabled(kpkStack)) {
                    player.sendMessage(new TextComponentString(TextFormatting.RED + "Вы должны держать в руках включенный КПК для отправки сообщений."));
                    return;
                }

                User user = ItemKPK.getUserData(kpkStack);

                if (user == null || user.pozivnoy == null || user.pozivnoy.isEmpty()) {
                    player.sendMessage(new TextComponentString(TextFormatting.RED + "Невозможно отправить сообщение: КПК не инициализирован или отсутствует позывной."));
                    return;
                }
                if (message.content == null || message.content.trim().isEmpty()) {
                    return;
                }
                if (message.content.length() > 256) {
                    player.sendMessage(new TextComponentString(TextFormatting.RED + "Сообщение слишком длинное."));
                    return;
                }

                ChatMessage chatMsg = new ChatMessage(
                        player.getUniqueID(),
                        user.pozivnoy,
                        player.getName(),
                        System.currentTimeMillis(),
                        message.content,
                        message.channelId
                );
                ChatManager.addMessageToChannel(player, chatMsg);
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketHandler.java =====
package com.example.examplemod.network;

import com.example.examplemod.ExampleMod;
import net.minecraftforge.fml.common.network.NetworkRegistry;
import net.minecraftforge.fml.common.network.simpleimpl.SimpleNetworkWrapper;
import net.minecraftforge.fml.relauncher.Side;

public class PacketHandler {
    public static SimpleNetworkWrapper INSTANCE;

    public static void init() {
        INSTANCE = NetworkRegistry.INSTANCE.newSimpleChannel(ExampleMod.MODID);
        registerMessages();
    }

    private static void registerMessages() {
        int id = 0;
        INSTANCE.registerMessage(PacketAddContactRequest.Handler.class, PacketAddContactRequest.class, id++, Side.SERVER);
        INSTANCE.registerMessage(PacketRemoveContactRequest.Handler.class, PacketRemoveContactRequest.class, id++, Side.SERVER);

        INSTANCE.registerMessage(PacketChatMessageToServer.Handler.class, PacketChatMessageToServer.class, id++, Side.SERVER);
        INSTANCE.registerMessage(PacketBroadcastChatMessageToClient.Handler.class, PacketBroadcastChatMessageToClient.class, id++, Side.CLIENT);
        INSTANCE.registerMessage(PacketSyncChatHistoryToClient.Handler.class, PacketSyncChatHistoryToClient.class, id++, Side.CLIENT);

        INSTANCE.registerMessage(PacketRequestCreatePMChannel.Handler.class, PacketRequestCreatePMChannel.class, id++, Side.SERVER);
        INSTANCE.registerMessage(PacketRequestCreateGroupChannel.Handler.class, PacketRequestCreateGroupChannel.class, id++, Side.SERVER);
        INSTANCE.registerMessage(PacketRequestAddUserToGroupChannel.Handler.class, PacketRequestAddUserToGroupChannel.class, id++, Side.SERVER);
        INSTANCE.registerMessage(PacketNotifyChannelCreatedOrUpdated.Handler.class, PacketNotifyChannelCreatedOrUpdated.class, id++, Side.CLIENT);
        INSTANCE.registerMessage(PacketSyncSubscribedChannels.Handler.class, PacketSyncSubscribedChannels.class, id++, Side.CLIENT);

        INSTANCE.registerMessage(PacketRequestDeleteChannel.Handler.class, PacketRequestDeleteChannel.class, id++, Side.SERVER);
        INSTANCE.registerMessage(PacketNotifyChannelDeleted.Handler.class, PacketNotifyChannelDeleted.class, id++, Side.CLIENT);

        INSTANCE.registerMessage(PacketRequestRemoveMember.Handler.class, PacketRequestRemoveMember.class, id++, Side.SERVER);

        // Новые пакеты
        INSTANCE.registerMessage(PacketSyncKpkDatabaseToClient.Handler.class, PacketSyncKpkDatabaseToClient.class, id++, Side.CLIENT);
        INSTANCE.registerMessage(PacketRequestChannelSync.Handler.class, PacketRequestChannelSync.class, id++, Side.SERVER);
    }
}===== com/example/examplemod/network/PacketNotifyChannelCreatedOrUpdated.java =====
package com.example.examplemod.network;

import com.example.examplemod.chat.ChatChannel;
import com.example.examplemod.chat.ClientChatCache;
import io.netty.buffer.ByteBuf;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class PacketNotifyChannelCreatedOrUpdated implements IMessage {
    private ChatChannel channel;

    public PacketNotifyChannelCreatedOrUpdated() {}

    public PacketNotifyChannelCreatedOrUpdated(ChatChannel channel) {
        this.channel = channel;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        this.channel = ChatChannel.fromBytes(buf);
    }

    @Override
    public void toBytes(ByteBuf buf) {
        this.channel.toBytes(buf);
    }

    public static class Handler implements IMessageHandler<PacketNotifyChannelCreatedOrUpdated, IMessage> {
        @Override
        @SideOnly(Side.CLIENT)
        public IMessage onMessage(PacketNotifyChannelCreatedOrUpdated message, MessageContext ctx) {
            Minecraft.getMinecraft().addScheduledTask(() -> {
                ClientChatCache.addOrUpdateChannel(message.channel);
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketNotifyChannelDeleted.java =====
package com.example.examplemod.network;

import com.example.examplemod.chat.ClientChatCache;
import io.netty.buffer.ByteBuf;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class PacketNotifyChannelDeleted implements IMessage {
    private String channelId;

    public PacketNotifyChannelDeleted() {}

    public PacketNotifyChannelDeleted(String channelId) {
        this.channelId = channelId;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        this.channelId = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBytes(ByteBuf buf) {
        ByteBufUtils.writeUTF8String(buf, this.channelId);
    }

    public static class Handler implements IMessageHandler<PacketNotifyChannelDeleted, IMessage> {
        @Override
        @SideOnly(Side.CLIENT)
        public IMessage onMessage(PacketNotifyChannelDeleted message, MessageContext ctx) {
            Minecraft.getMinecraft().addScheduledTask(() -> {
                ClientChatCache.removeChannel(message.channelId);
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketRemoveContactRequest.java =====
package com.example.examplemod.network;

import com.example.examplemod.item.ItemKPK;
import io.netty.buffer.ByteBuf;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.EnumHand;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextFormatting;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;

import java.util.List;

public class PacketRemoveContactRequest implements IMessage {

    private String contactNameToRemove;

    public PacketRemoveContactRequest() {
    }

    public PacketRemoveContactRequest(String contactNameToRemove) {
        this.contactNameToRemove = contactNameToRemove;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        this.contactNameToRemove = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBytes(ByteBuf buf) {
        ByteBufUtils.writeUTF8String(buf, this.contactNameToRemove);
    }

    public static class Handler implements IMessageHandler<PacketRemoveContactRequest, IMessage> {
        @Override
        public IMessage onMessage(PacketRemoveContactRequest message, MessageContext ctx) {
            EntityPlayerMP player = ctx.getServerHandler().player;
            MinecraftServer server = player.getServer();

            server.addScheduledTask(() -> {
                System.out.println("[KPK-DEBUG] Received PacketRemoveContactRequest for callsign: " + message.contactNameToRemove);

                EnumHand hand = EnumHand.MAIN_HAND;
                ItemStack kpkStack = player.getHeldItemMainhand();
                if (!(kpkStack.getItem() instanceof ItemKPK)) {
                    kpkStack = player.getHeldItemOffhand();
                    hand = EnumHand.OFF_HAND;
                }

                if (!(kpkStack.getItem() instanceof ItemKPK)) {
                    player.sendMessage(new TextComponentString(TextFormatting.RED + "Вы должны держать КПК в руке."));
                    System.out.println("[KPK-DEBUG] Player not holding KPK for removal.");
                    return;
                }

                List<String> currentContacts = ItemKPK.getContacts(kpkStack);
                System.out.println("[KPK-DEBUG] Pre-remove contacts: " + currentContacts.toString());

                if (currentContacts.contains(message.contactNameToRemove)) {
                    ItemKPK.removeContact(kpkStack, message.contactNameToRemove);
                    System.out.println("[KPK-DEBUG] Post-remove contacts: " + ItemKPK.getContacts(kpkStack).toString());
                    player.sendMessage(new TextComponentString(TextFormatting.GREEN + "Контакт '" + message.contactNameToRemove + "' удален из вашего КПК."));

                    player.setHeldItem(hand, kpkStack);
                    player.inventory.markDirty();
                    System.out.println("[KPK-DEBUG] Updated and synced ItemStack after removal.");

                } else {
                    player.sendMessage(new TextComponentString(TextFormatting.YELLOW + "Контакт '" + message.contactNameToRemove + "' не найден в вашем КПК."));
                    System.out.println("[KPK-DEBUG] Contact to remove was not found in the list.");
                }
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketRequestAddUserToGroupChannel.java =====
package com.example.examplemod.network;

import com.example.examplemod.chat.ChatManager;
import io.netty.buffer.ByteBuf;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;

public class PacketRequestAddUserToGroupChannel implements IMessage {
    private String channelId;
    private String targetUserCallsign;

    public PacketRequestAddUserToGroupChannel() {}

    public PacketRequestAddUserToGroupChannel(String channelId, String targetUserCallsign) {
        this.channelId = channelId;
        this.targetUserCallsign = targetUserCallsign;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        this.channelId = ByteBufUtils.readUTF8String(buf);
        this.targetUserCallsign = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBytes(ByteBuf buf) {
        ByteBufUtils.writeUTF8String(buf, this.channelId);
        ByteBufUtils.writeUTF8String(buf, this.targetUserCallsign);
    }

    public static class Handler implements IMessageHandler<PacketRequestAddUserToGroupChannel, IMessage> {
        @Override
        public IMessage onMessage(PacketRequestAddUserToGroupChannel message, MessageContext ctx) {
            EntityPlayerMP sender = ctx.getServerHandler().player;
            sender.getServer().addScheduledTask(() -> {
                ChatManager.addPlayerToGroupChannelByCallsign(message.channelId, message.targetUserCallsign, sender);
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketRequestChannelSync.java =====
package com.example.examplemod.network;

import com.example.examplemod.chat.ChatManager;
import io.netty.buffer.ByteBuf;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;

public class PacketRequestChannelSync implements IMessage {

    public PacketRequestChannelSync() {}

    @Override
    public void fromBytes(ByteBuf buf) {}

    @Override
    public void toBytes(ByteBuf buf) {}

    public static class Handler implements IMessageHandler<PacketRequestChannelSync, IMessage> {
        @Override
        public IMessage onMessage(PacketRequestChannelSync message, MessageContext ctx) {
            EntityPlayerMP player = ctx.getServerHandler().player;
            player.getServer().addScheduledTask(() -> {
                ChatManager.onPlayerLogin(player); // Используем существующий метод для полной синхронизации
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketRequestCreateGroupChannel.java =====
package com.example.examplemod.network;

import com.example.examplemod.User;
import com.example.examplemod.chat.ChatManager;
import com.example.examplemod.item.ItemKPK;
import io.netty.buffer.ByteBuf;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextFormatting;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class PacketRequestCreateGroupChannel implements IMessage {
    private String channelName;
    private List<String> memberCallsigns;

    public PacketRequestCreateGroupChannel() {
        this.memberCallsigns = new ArrayList<>();
    }

    public PacketRequestCreateGroupChannel(String channelName, List<String> memberCallsigns) {
        this.channelName = channelName;
        this.memberCallsigns = memberCallsigns;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        this.channelName = ByteBufUtils.readUTF8String(buf);
        int size = buf.readInt();
        this.memberCallsigns = new ArrayList<>(size);
        for (int i = 0; i < size; i++) {
            this.memberCallsigns.add(ByteBufUtils.readUTF8String(buf));
        }
    }

    @Override
    public void toBytes(ByteBuf buf) {
        ByteBufUtils.writeUTF8String(buf, this.channelName);
        buf.writeInt(this.memberCallsigns.size());
        for (String callsign : this.memberCallsigns) {
            ByteBufUtils.writeUTF8String(buf, callsign);
        }
    }

    public static class Handler implements IMessageHandler<PacketRequestCreateGroupChannel, IMessage> {
        @Override
        public IMessage onMessage(PacketRequestCreateGroupChannel message, MessageContext ctx) {
            EntityPlayerMP sender = ctx.getServerHandler().player;
            MinecraftServer server = sender.getServer();
            sender.getServer().addScheduledTask(() -> {
                List<UUID> memberUuids = new ArrayList<>();
                boolean allFound = true;
                for (String callsign : message.memberCallsigns) {
                    EntityPlayerMP targetPlayer = null;
                    for (EntityPlayerMP p : server.getPlayerList().getPlayers()) {
                        ItemStack kpkStack = p.getHeldItemMainhand();
                        if (!(kpkStack.getItem() instanceof ItemKPK)) kpkStack = p.getHeldItemOffhand();

                        if (kpkStack.getItem() instanceof ItemKPK) {
                            User kpkUser = ItemKPK.getUserData(kpkStack);
                            if (kpkUser != null && callsign.equalsIgnoreCase(kpkUser.pozivnoy)) {
                                targetPlayer = p;
                                break;
                            }
                        }
                    }
                    if (targetPlayer != null) {
                        memberUuids.add(targetPlayer.getUniqueID());
                    } else {
                        sender.sendMessage(new TextComponentString(TextFormatting.RED + "Не удалось найти участника с позывным: " + callsign + ". Канал не создан."));
                        allFound = false;
                        break;
                    }
                }

                if (allFound) {
                    ChatManager.createPrivateGroupChannel(sender, message.channelName, memberUuids);
                }
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketRequestCreatePMChannel.java =====
package com.example.examplemod.network;

import com.example.examplemod.User;
import com.example.examplemod.chat.ChatManager;
import com.example.examplemod.item.ItemKPK;
import io.netty.buffer.ByteBuf;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextFormatting;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;

public class PacketRequestCreatePMChannel implements IMessage {
    private String targetPlayerCallsign;

    public PacketRequestCreatePMChannel() {}

    public PacketRequestCreatePMChannel(String targetPlayerCallsign) {
        this.targetPlayerCallsign = targetPlayerCallsign;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        this.targetPlayerCallsign = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBytes(ByteBuf buf) {
        ByteBufUtils.writeUTF8String(buf, this.targetPlayerCallsign);
    }

    public static class Handler implements IMessageHandler<PacketRequestCreatePMChannel, IMessage> {
        @Override
        public IMessage onMessage(PacketRequestCreatePMChannel message, MessageContext ctx) {
            EntityPlayerMP sender = ctx.getServerHandler().player;
            MinecraftServer server = sender.getServer();
            server.addScheduledTask(() -> {
                EntityPlayerMP targetPlayer = null;
                for (EntityPlayerMP p : server.getPlayerList().getPlayers()) {
                    ItemStack kpkStack = p.getHeldItemMainhand();
                    if (!(kpkStack.getItem() instanceof ItemKPK)) kpkStack = p.getHeldItemOffhand();

                    if (kpkStack.getItem() instanceof ItemKPK) {
                        User kpkUser = ItemKPK.getUserData(kpkStack);
                        if (kpkUser != null && message.targetPlayerCallsign.equalsIgnoreCase(kpkUser.pozivnoy)) {
                            targetPlayer = p;
                            break;
                        }
                    }
                }

                if (targetPlayer != null) {
                    ChatManager.createPrivateMessageChannel(sender, targetPlayer.getUniqueID());
                } else {
                    sender.sendMessage(new TextComponentString(TextFormatting.RED + "Игрок с позывным '" + message.targetPlayerCallsign + "' не найден, оффлайн или не держит КПК в руке."));
                }
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketRequestDeleteChannel.java =====
package com.example.examplemod.network;

import com.example.examplemod.chat.ChatManager;
import io.netty.buffer.ByteBuf;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;

public class PacketRequestDeleteChannel implements IMessage {
    private String channelId;

    public PacketRequestDeleteChannel() {}

    public PacketRequestDeleteChannel(String channelId) {
        this.channelId = channelId;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        this.channelId = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBytes(ByteBuf buf) {
        ByteBufUtils.writeUTF8String(buf, this.channelId);
    }

    public static class Handler implements IMessageHandler<PacketRequestDeleteChannel, IMessage> {
        @Override
        public IMessage onMessage(PacketRequestDeleteChannel message, MessageContext ctx) {
            EntityPlayerMP player = ctx.getServerHandler().player;
            player.getServer().addScheduledTask(() -> {
                ChatManager.deleteChannel(message.channelId, player);
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketRequestRemoveMember.java =====
package com.example.examplemod.network;

import com.example.examplemod.chat.ChatManager;
import io.netty.buffer.ByteBuf;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;

import java.util.UUID;

public class PacketRequestRemoveMember implements IMessage {
    private String channelId;
    private UUID memberToRemoveUuid;

    public PacketRequestRemoveMember() {}

    public PacketRequestRemoveMember(String channelId, UUID memberToRemoveUuid) {
        this.channelId = channelId;
        this.memberToRemoveUuid = memberToRemoveUuid;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        this.channelId = ByteBufUtils.readUTF8String(buf);
        this.memberToRemoveUuid = UUID.fromString(ByteBufUtils.readUTF8String(buf));
    }

    @Override
    public void toBytes(ByteBuf buf) {
        ByteBufUtils.writeUTF8String(buf, this.channelId);
        ByteBufUtils.writeUTF8String(buf, this.memberToRemoveUuid.toString());
    }

    public static class Handler implements IMessageHandler<PacketRequestRemoveMember, IMessage> {
        @Override
        public IMessage onMessage(PacketRequestRemoveMember message, MessageContext ctx) {
            EntityPlayerMP requester = ctx.getServerHandler().player;
            requester.getServer().addScheduledTask(() -> {
                ChatManager.removeMemberFromGroupChannel(message.channelId, message.memberToRemoveUuid, requester);
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketSyncChatHistoryToClient.java =====
package com.example.examplemod.network;

import com.example.examplemod.chat.ChatMessage;
import com.example.examplemod.chat.ClientChatCache;
import io.netty.buffer.ByteBuf;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.List;

public class PacketSyncChatHistoryToClient implements IMessage {
    private String channelId;
    private List<ChatMessage> history;

    public PacketSyncChatHistoryToClient() {}

    public PacketSyncChatHistoryToClient(String channelId, List<ChatMessage> history) {
        this.channelId = channelId;
        this.history = history;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        this.channelId = ByteBufUtils.readUTF8String(buf);
        int size = buf.readInt();
        this.history = new ArrayList<>(size);
        for (int i = 0; i < size; i++) {
            this.history.add(ChatMessage.fromBytes(buf));
        }
    }

    @Override
    public void toBytes(ByteBuf buf) {
        ByteBufUtils.writeUTF8String(buf, this.channelId);
        buf.writeInt(this.history.size());
        for (ChatMessage msg : this.history) {
            msg.toBytes(buf);
        }
    }

    public static class Handler implements IMessageHandler<PacketSyncChatHistoryToClient, IMessage> {
        @Override
        @SideOnly(Side.CLIENT)
        public IMessage onMessage(PacketSyncChatHistoryToClient message, MessageContext ctx) {
            Minecraft.getMinecraft().addScheduledTask(() -> {
                ClientChatCache.setHistory(message.channelId, message.history);
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketSyncKpkDatabaseToClient.java =====
package com.example.examplemod.network;

import com.example.examplemod.Gender;
import com.example.examplemod.User;
import com.example.examplemod.chat.ClientChatCache;
import io.netty.buffer.ByteBuf;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class PacketSyncKpkDatabaseToClient implements IMessage {

    private Map<UUID, User> kpkDatabase;
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy");

    public PacketSyncKpkDatabaseToClient() {}

    public PacketSyncKpkDatabaseToClient(Map<UUID, User> kpkDatabase) {
        this.kpkDatabase = kpkDatabase;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        int size = buf.readInt();
        this.kpkDatabase = new HashMap<>(size);
        for (int i = 0; i < size; i++) {
            UUID uuid = UUID.fromString(ByteBufUtils.readUTF8String(buf));
            String familiya = ByteBufUtils.readUTF8String(buf);
            String name = ByteBufUtils.readUTF8String(buf);
            String pozivnoy = ByteBufUtils.readUTF8String(buf);
            Gender gender = Gender.valueOf(ByteBufUtils.readUTF8String(buf));
            LocalDate birthdate = LocalDate.parse(ByteBufUtils.readUTF8String(buf), DATE_FORMATTER);
            this.kpkDatabase.put(uuid, new User(familiya, name, pozivnoy, gender, birthdate));
        }
    }

    @Override
    public void toBytes(ByteBuf buf) {
        buf.writeInt(this.kpkDatabase.size());
        for (Map.Entry<UUID, User> entry : this.kpkDatabase.entrySet()) {
            ByteBufUtils.writeUTF8String(buf, entry.getKey().toString());
            User user = entry.getValue();
            ByteBufUtils.writeUTF8String(buf, user.familiya);
            ByteBufUtils.writeUTF8String(buf, user.name);
            ByteBufUtils.writeUTF8String(buf, user.pozivnoy);
            ByteBufUtils.writeUTF8String(buf, user.gender.name());
            ByteBufUtils.writeUTF8String(buf, user.birthdate.format(DATE_FORMATTER));
        }
    }

    public static class Handler implements IMessageHandler<PacketSyncKpkDatabaseToClient, IMessage> {
        @Override
        @SideOnly(Side.CLIENT)
        public IMessage onMessage(PacketSyncKpkDatabaseToClient message, MessageContext ctx) {
            Minecraft.getMinecraft().addScheduledTask(() -> {
                ClientChatCache.setKpkUserDatabase(message.kpkDatabase);
            });
            return null;
        }
    }
}===== com/example/examplemod/network/PacketSyncSubscribedChannels.java =====
package com.example.examplemod.network;

import com.example.examplemod.chat.ChatChannel;
import com.example.examplemod.chat.ClientChatCache;
import io.netty.buffer.ByteBuf;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.List;

public class PacketSyncSubscribedChannels implements IMessage {
    private List<ChatChannel> channels;

    public PacketSyncSubscribedChannels() {
        this.channels = new ArrayList<>();
    }

    public PacketSyncSubscribedChannels(List<ChatChannel> channels) {
        this.channels = channels;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        int size = buf.readInt();
        this.channels = new ArrayList<>(size);
        for (int i = 0; i < size; i++) {
            this.channels.add(ChatChannel.fromBytes(buf));
        }
    }

    @Override
    public void toBytes(ByteBuf buf) {
        buf.writeInt(this.channels.size());
        for (ChatChannel channel : this.channels) {
            channel.toBytes(buf);
        }
    }

    public static class Handler implements IMessageHandler<PacketSyncSubscribedChannels, IMessage> {
        @Override
        @SideOnly(Side.CLIENT)
        public IMessage onMessage(PacketSyncSubscribedChannels message, MessageContext ctx) {
            Minecraft.getMinecraft().addScheduledTask(() -> {
                ClientChatCache.setSubscribedChannels(message.channels);
            });
            return null;
        }
    }
}===== com/example/examplemod/proxy/ClientProxy.java =====
package com.example.examplemod.proxy;

import com.example.examplemod.ExampleMod;
import com.example.examplemod.gui.GuiHandler;
import com.example.examplemod.gui.KPKModelInteractionGui;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class ClientProxy extends CommonProxy {

    @Override
    public void sendMessageToPlayer(EntityPlayer player, TextComponentString message) {
    }

    @Override
    public void openKPKGui(EntityPlayer player, World world, int x, int y, int z) {
        player.openGui(ExampleMod.instance, GuiHandler.KPK_MODEL_INTERACTION_GUI_ID, world, x, y, z);
    }

    @Override
    public boolean isKPKGuiOpen() {
        return Minecraft.getMinecraft().currentScreen instanceof KPKModelInteractionGui;
    }

    @Override
    public void closeKPKGui(EntityPlayer player) {
        if (player == Minecraft.getMinecraft().player && Minecraft.getMinecraft().currentScreen != null) {
            player.closeScreen();
        }
    }

    @Override
    public boolean isClient() {
        return true;
    }
}===== com/example/examplemod/proxy/CommonProxy.java =====
package com.example.examplemod.proxy;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.world.World;

public class CommonProxy implements IProxy {
    @Override
    public void playSound(String soundName, float volume, float pitch) {
    }

    @Override
    public void sendMessageToPlayer(EntityPlayer player, TextComponentString message) {
        player.sendMessage(message);
    }

    @Override
    public void openKPKGui(EntityPlayer player, World world, int x, int y, int z) {
    }

    @Override
    public boolean isKPKGuiOpen() {
        return false;
    }

    @Override
    public void closeKPKGui(EntityPlayer player) {
    }

    @Override
    public boolean isClient() {
        return false;
    }
}===== com/example/examplemod/proxy/IProxy.java =====
package com.example.examplemod.proxy;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.world.World;

public interface IProxy {
    void playSound(String soundName, float volume, float pitch);
    void sendMessageToPlayer(EntityPlayer player, TextComponentString message);
    void openKPKGui(EntityPlayer player, World world, int x, int y, int z);
    boolean isKPKGuiOpen();
    void closeKPKGui(EntityPlayer player);
    boolean isClient();
}===== com/example/examplemod/User.java =====
package com.example.examplemod;

import java.time.LocalDate;

public class User {
    public String familiya;
    public String name;
    public String pozivnoy;
    public Gender gender;
    public LocalDate birthdate;
    public User(String familiya, String name, String pozivnoy, Gender gender, LocalDate birthdate) {
        this.familiya = familiya;
        this.name = name;
        this.pozivnoy = pozivnoy;
        this.gender = gender;
        this.birthdate = birthdate;
    }
}
